<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>000 An Introduction to LLVM(KOR) | Yongjin Han</title> <meta name="author" content="Yongjin Han"/> <meta name="description" content="LLVM"/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚛️</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://dalnaracrater.github.io/blog/2024/000-Begining_LLVM(KOR)/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Yongjin&nbsp;</span>Han</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="toggle-container"> <button id="light-toggle" title="dark mode is classy!. Yongjin"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">000 An Introduction to LLVM(KOR)</h1> <p class="post-meta">April 24, 2024</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a> &nbsp; &middot; &nbsp; <a href="/blog/tag/llvm"> <i class="fa-solid fa-hashtag fa-sm"></i> LLVM</a> &nbsp; </p> </header> <article class="post-content"> <div id="markdown-content"> <p>GPU의 등장으로 인공지능 연구에 엄청난 발전이 시작되었다. 스팸메일 탐지, MRI 영상 처리, 심지어는 잡초 이미지를 학습하여 농기구에 부착된 카메라를 통해 잡초를 인식하고 레이저로 제거하는 기술까지 모든 분야에서 인공지능 기술을 활용하고 있다. 또한 불과 2~3년 사이에 ChatGPT, LLaMa, Bard와 같은 트랜스포머(transformer) 기반의 모델은 이미 우리의 삶 어딘가에 자리잡기 시작했다. 잠깐! LLVM 튜토리얼 아니었나? 맞다! 근데 왜 갑자기 인공지능 이야기를 하는가? 왜냐하면 컴파일러 또한 인공지능과 관련이 있기 때문이다! 인공지능 모델 또한 결국 CPU, GPU, TPU에서 처리해야 하기 때문에 더 빠르고 최적화된 컴파일러를 필요로 한다. MLIR, XLA, Triton과 같이 특정 도메인에서 유용한 컴파일러 프레임워크가 등장하였으며, 이 프레임워크를 통해 딥러닝 모델의 학습을 가속화시킬 수 있다.<br/> LLVM은 좀 더 범용적으로 사용할 수 있는 컴파일러 프레임워크 중 하나이지만 다소 높은 진입 장벽을 갖고 있으며, 나 또한 이러한 장벽에 좌절을 했던 한 학생이었다. 하지만 이제는 제법 LLVM에 대해 잘 알고 있으며 이론으로만 배웠던 프로그램 분석 기법들이 어떻게 구현이 되고 적용되는지 알아냈다. 나는 나와 같은 어려움을 겪고 있는 학생들을 위해 간단한 튜토리얼을 작성해본다.</p> <p><em>본 튜토리얼에서는 프로그램 분석 기법을 LLVM을 통해 구현해보는 것이 목적이기 때문에 모든 이론적 지식을 자세하게 다루지는 않을 것이다.</em></p> <h2 id="llvm이란">LLVM이란?</h2> <p>LLVM은 프로그래밍 언어를 설계하고 최적화할 수 있게 해주는 컴파일러 도구이다. (Front-end) (Middle-end) 변환된 LLVM IR을 최적화하여 새로운 LLVM IR을 출력한다. (Back-end) 최적화된 IR 코드는 기계에 종속적인 실행 파일로 변환된다.</p> <h3 id="learning-objectives">Learning Objectives</h3> <ul> <li>컴파일 과정에 대해 이해한다</li> <li>SSA 형태가 무엇인지 공부한다</li> <li>LLVM 프로젝트를 설치하고 빌드하는 방법을 알아본다</li> <li>LLVM Pass를 작성하는 법을 살펴본다.</li> <li>LLVM IR로 변환된 프로그램의 기본 구조를 살펴본다.</li> </ul> <h3 id="compilation-process">Compilation process</h3> <p>컴파일 과정을 이해하면 LLVM을 사용하는데 큰 도움이 된다. 흔히 빌드 과정과 컴파일 과정을 헷갈려하는데 이에 대해 간단하게 짚고 넘어가고자 한다.<br/> 먼저 빌드 과정을 살펴보자. 소스코드 빌드는 보통 전처리 -&gt; 컴파일 -&gt; 어셈블 -&gt; 링크 순서로 진행되어 최종적으로 프로그램이 실행될 기계에서 실행할 수 있는 실행파일이 생성된다. 우리가 앞으로 다루고자 하는 최적화는 빌드 과정의 컴파일에서 수행된다.</p> <p>다음은 컴파일 과정을 도식화한 그림이다.</p> <p>컴파일 과정은 크게 전단부와 후단부로 나뉘며 전단부를 좀 더 세밀하게 나누면 전단부와 중단부로 다시 나눌 수 있다. 전단부에서는 어휘분석, 구문분석, 의미분석을 수행하고, 중단부에서는 최적화를, 후단부에서는 기계어로의 변환 작업을 수행한다.</p> <ul> <li>Front-end: Convert a high level programming langauge into LLVM IR <ul> <li>Lexical analysis: Scan a source code and check whether it follows designated patterns by tokens. Return a series of tokens, otherwise omit an error.</li> <li>syntax analysis: Given a series of tokens, create a Abstract Syntax Tree (AST)</li> <li>semantic analysis: analyze a source code whether it has semantic errors or not. (e.g. Type check, Arithmetics) Return Abstract Syntax Tree (AST)</li> </ul> </li> <li>Middle-end: Optimize LLVM IR via LLVM Pass <ul> <li>optimization: optimize a source code.</li> </ul> </li> <li>Back-end: Translate a optimized IR into a machine dependent assembly language.</li> </ul> <h3 id="ssa">SSA</h3> <p>LLVM이 소스코드를 최적화하기 위해서는 gcc, llc와 같은 컴파일 도구를 이용해 소스코드를 LLVM IR로 변환해야 한다. 이때 LLVM IR은 Static Single Assignment (SSA) 형태를 따르는데, 이는 변수에 값이 오직 한번만 할당되고, 그 이후에는 그 변수를 읽는데만 사용할 수 있도록 한다. SSA 형태로 코드를 변환하면 코드 최적화에 도움이 되는데 이는 그래프 기반의 최적화와 같이 흐름 분석을 하는데 유용하기 때문이다.</p> <ul> <li>Fig</li> </ul> <p>자, 이제 LLVM에 대한 기본적인 개념을 소개했으니 어떻게 사용하는지 알아보도록 하자.</p> <h3 id="installing-llvm">Installing LLVM</h3> <p><a href="https://llvm.org/docs/GettingStarted.html">LLVM 공식 홈페이지</a>에서 LLVM 설치에 대한 더 자세한 설명이 있으니 참고하면 좋을 것 같다.</p> <h4 id="required-software">required software</h4> <p><code class="language-plaintext highlighter-rouge">CMake</code>: <code class="language-plaintext highlighter-rouge">brew install CMake</code><br/> <code class="language-plaintext highlighter-rouge">Ninja</code>: <code class="language-plaintext highlighter-rouge">brew install Ninja</code><br/> <code class="language-plaintext highlighter-rouge">Clang</code>: <code class="language-plaintext highlighter-rouge">brew install Clang</code></p> <h4 id="clone-git">Clone Git</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/llvm/llvm-project.git llvm
cd llvm
</code></pre></div></div> <h4 id="build-llvm-project">Build LLVM project</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir build
cd build
ninja
</code></pre></div></div> <p>Ninja를 통해 프로젝트를 처음 빌드하게 되면 대략 30분 정도의 시간이 소요된다. 하지만 이후에 다시 빌드를 하게 되면 몇 분 내외로 빌드가 완료되니 걱정하지 말자.</p> <p>빌드된 llvm의 실행파일을 손쉽게 사용하기 위해 실행환경을 수정해 준다. <em>(프로그램이 실행되지 않을 때 뿐만 아니라 LLVM 패스를 작성할 때 라이브러리가 인식이 안되는 문제도 해결해준다.)</em></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PATH=$PATH:~/llvm/build/bin/
</code></pre></div></div> <h4 id="compile-a-source-code-into-ll-or-bc">Compile a source code into *.ll or *.bc</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -emit-llvm -S test.cpp -o test.ll
</code></pre></div></div> <h3 id="writing-an-llvm-pass">Writing an LLVM Pass</h3> <p>처음으로 만들어 볼 패스는 “Hello LLVM!”을 출력하는 Hello 패스이다.</p> <ol> <li>우선 LLVM 패스 파일을 위한 <code class="language-plaintext highlighter-rouge">HelloLLVM</code> 디렉토리를 <code class="language-plaintext highlighter-rouge">./llvm/llvm/lib/Transforms/</code>에 만들자.</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir HelloLLVM
cd HelloLLVM
</code></pre></div></div> <h6 id="주의-현재-우리가-위치한-디렉토리는-llvmllvmlibtransformshellollvm이고-패스-파일을-빌드하면-llvmbuildlib에-빌드된-패스가-생성된다"><em>주의. 현재 우리가 위치한 디렉토리는 <code class="language-plaintext highlighter-rouge">~/llvm/llvm/lib/Transforms/HelloLLVM/</code>이고 패스 파일을 빌드하면 <code class="language-plaintext highlighter-rouge">~/llvm/build/lib/</code>에 빌드된 패스가 생성된다</em></h6> <p>패스를 작성하기 위해서는 빌드를 위한 <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>와 LLVM 소스코드 파일, <code class="language-plaintext highlighter-rouge">HelloLLVM.cpp</code>이 필요하다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>touch CMakeLists.txt
touch HelloLLVM.cpp
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> 파일에 들어갈 내용은 다음과 같다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add_llvm_library(HELLO MODULE
    HELLO.cpp
    
    PLUGIN_TOOL
    OPT)
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Transforms</code> 디렉토리에 위치한 <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>에도 맨 마지막에 <code class="language-plaintext highlighter-rouge">add_subdirectory(HelloLLVM)</code>을 추가해주자.</p> <p>자 이제 진정한 LLVM Pass를 작성해보자!</p> <h4 id="library-header">library header</h4> <p>우리가 작성하려는 <strong>패스</strong> 파일은 소스코드를 <strong>함수 단위</strong>로 분석하고 이때 “Hello LLVM!”을 <strong>출력</strong>하는 것이다. 따라서 이에 맞게 사용할 라이브러리는 다음과 같다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/Pass.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span></code></pre></div></div> <p>llvm은 이름공간을 사용하므로 편의를 위해 다음을 선언해주자.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
</code></pre></div></div> <p>다음으로는 새로운 이름 공간 안에 FunctionPass를 상속받는 HelloLLVM 구조체를 선언하자. 이 구조체의 멤버 함수가 실질적인 최적화 작업을 수행할 것이다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">HelloLLVM</span><span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span><span class="p">{</span>
        <span class="c1">// You will write a Pass here! </span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p>llvm은 패스마다 고유의 <code class="language-plaintext highlighter-rouge">ID</code>가 있기 때문에 <code class="language-plaintext highlighter-rouge">ID</code>를 스태틱 변수로 선언해준다. <code class="language-plaintext highlighter-rouge">FunctionPass</code>의 생성자를 통해 고유한 ID값을 갖게 하고 다른 패스들과 구분할 수 있게 만들어준다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
<span class="n">HelloLLVM</span><span class="p">()</span> <span class="o">:</span> <span class="n">FunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <p>소스코드를 함수 단위로 분석하기 위해 <code class="language-plaintext highlighter-rouge">bool runOnFunction()</code> 함수를 재정의(override)한다. 이 함수는 소스코드를 변경했으면 <code class="language-plaintext highlighter-rouge">true</code>를 아니면 <code class="language-plaintext highlighter-rouge">false</code>를 반환한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">){</span>
    <span class="c1">// this code optimize a given source code over the function F.</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">C</code>언어의 <code class="language-plaintext highlighter-rouge">printf</code>, <code class="language-plaintext highlighter-rouge">C++</code>의 <code class="language-plaintext highlighter-rouge">cout</code>과 같이 llvm에서는 <code class="language-plaintext highlighter-rouge">errs()</code>를 출력 스트림으로 사용한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello LLVM!"</span><span class="p">;</span>
</code></pre></div></div> <p>We will write an LLVM Pass and this pass run over functions in a program. To print ‘Hello LLVM!’ out, we need to specify which stream we use. In this case, the output stream is <code class="language-plaintext highlighter-rouge">errs()</code></p> <p>In llvm, a pass has an unique ID so we define <code class="language-plaintext highlighter-rouge">char ID</code> as static.</p> <p>최적화를 위한 패스를 완성하였다. 이제는 이 패스를 등록하는 일만 남았다. 먼저 패스의 <code class="language-plaintext highlighter-rouge">ID</code>를 <code class="language-plaintext highlighter-rouge">0</code>으로 설정해주고(아무런 의미가 없기 때문), <code class="language-plaintext highlighter-rouge">RegisterPass</code>를 통해 패스를 등록한다. llvm에서는 패스가 고유의 ID를 갖지만, 이 고유성은 <code class="language-plaintext highlighter-rouge">ID</code>가 <code class="language-plaintext highlighter-rouge">0</code>값을 갖을 때 할당되는 메모리 공간을 통해 다른 패스들과 구분되게 한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">HelloLLVM</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">HelloLLVM</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"PrintHello"</span><span class="p">,</span> <span class="s">"Print Hello LLVM!"</span><span class="p">,</span>
                            <span class="nb">false</span> <span class="cm">/* Only looks at CFG */</span><span class="p">,</span>
                            <span class="nb">false</span> <span class="cm">/* Analysis Pass */</span><span class="p">);</span>
</code></pre></div></div> <p>위 방식은 <strong>legacy Pass Manager</strong>를 통해 패스를 등록한 것이다. 이 방식은 스케줄링, 메모리 관리 등에 여러 불편함이 있었는데 이를 해소하기 위해 <strong>New Pass Manager</strong>가 등장했다. 그래서 최근에는 이 <strong>New Pass Manger</strong>를 통해 패스를 등록하는 추세이다.</p> <p>자 이제 패스 파일을 완성했으니 빌드하고 실제 코드에 적용해보자.</p> <p>먼저 <code class="language-plaintext highlighter-rouge">Ninja</code>를 통해 llvm을 빌드한다. 첫 빌드와 달리 단 몇 십 초만에 빌드가 끝난다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~/llvm/build/
ninja
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">hello.cpp</code> 파일이 있는 <code class="language-plaintext highlighter-rouge">~/llvm/testcases/</code>로 이동하자. <em>(다른 곳에서 실행해도 된다.)</em></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~/llvm/testcases/
clang -emit-llvm -S hello.cpp -o hello.ll
opt -load ../build/lib/HelloLLVM.so &lt; hello.ll &gt; /dev/null
</code></pre></div></div> <p>혹시 <code class="language-plaintext highlighter-rouge">HelloLLVM.so</code>가 없는가? 운영체제에 따라 생성되는 파일이 다르니 다시 한번 살펴보자. 필자는 Mac OS를 사용하기 때문에 <code class="language-plaintext highlighter-rouge">*.dylib</code>가 생성된다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello LLVM!
</code></pre></div></div> <p>자 방금 “Hello LLVM!”을 터미널에 출력하였다. 이는 hello.ll 파일을 최적화 하는 과정에서 해당 메시지를 출력한 것이다. LLVM의 세계에 온 것을 환영한다!</p> <h4 id="full-code">Full code</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"llvm/IR/Function.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/Support/raw_ostream.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">HelloLLVM</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>

        <span class="n">HelloLLVM</span><span class="p">()</span> <span class="o">:</span> <span class="n">FunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="p">{}</span>

        <span class="kt">bool</span> <span class="n">runOnFunction</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello LLVM!"</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span> <span class="c1">// end of struct</span>
<span class="p">}</span>  <span class="c1">// end of anonymous namespace</span>

<span class="kt">char</span> <span class="n">HelloLLVM</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">HelloLLVM</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"PrintHello"</span><span class="p">,</span> <span class="s">"Print Hello LLVM!"</span><span class="p">,</span>
                            <span class="nb">false</span> <span class="cm">/* Only looks at CFG */</span><span class="p">,</span>
                            <span class="nb">false</span> <span class="cm">/* Analysis Pass */</span><span class="p">);</span>
</code></pre></div></div> <h3 id="llvm-structure">LLVM structure</h3> <ul> <li>Module</li> <li>Function</li> <li>BasicBlock</li> <li>Instruction</li> </ul> <p>HelloLLVM 패스는 각 함수마다 최적화(“Hello LLVM!” 출력하기)를 수행한다. 이렇듯 최적화 패스를 작성하기 위해서는 LLVM IR의 구조를 알아야 하는데 위 그림에서와 같이 크게 <code class="language-plaintext highlighter-rouge">Module</code>, <code class="language-plaintext highlighter-rouge">Function</code>, <code class="language-plaintext highlighter-rouge">BasicBlock</code>, <code class="language-plaintext highlighter-rouge">Instruction</code>으로 나눌 수 있다. <code class="language-plaintext highlighter-rouge">Instruction</code>이 모여 <code class="language-plaintext highlighter-rouge">BasicBlock</code>을 구성하고, <code class="language-plaintext highlighter-rouge">BasicBlock</code>이 모여 <code class="language-plaintext highlighter-rouge">Function</code>을 구성한다. 마지막으로 <code class="language-plaintext highlighter-rouge">Function</code>이 모여 <code class="language-plaintext highlighter-rouge">Module</code>을 구성한다. 각 구조는 <code class="language-plaintext highlighter-rouge">loop statement</code>를 통해 탐색할 수 있으며 이는 다음에 알아보도록 하자.</p> <h3 id="pass-manager">Pass Manager</h3> <p>Legacy pass manager은</p> <h4 id="legacy-pass-manager">Legacy pass manager</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">llvmPass000</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">RegisterPass</span><span class="o">&lt;</span><span class="n">llvmPass000</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="s">"command"</span><span class="p">,</span> <span class="s">"description"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <h4 id="new-pass-manager">New pass manager</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h3 id="analysis-vs-transformation">Analysis vs Transformation</h3> <p><strong>프로그램 분석(Program analysis)</strong>은 프로그램을 수정하지 않는 선에서 수행할 수 있는 분석 기법을 말한다. 이러한 분석은 정의하지 않는 행위(undefined behavior)를 찾아내는데 자주 사용되며, 포인터 오용(misuse of pointer), 사용하지 않는 변수 찾기(unused variable), 메모리 참조(memory reference) 등이 있다.<br/> 반면에 <strong>프로그램 변환(Program transform)</strong>은 프로그램을 조사하는 것 뿐만 아니라, 프로그램을 수정하여 올바르게 동작하도록 하거나, 같은 동작을 수행하지만 좀 더 빨르게 해주는 최적화 작업에 사용한다. 죽은 코드 제거(dead code elimination), 상수 전파(constant propagation) 등이 프로그램 변환의 예시라 할 수 있다.</p> <p>프로그램 분석을 위해서는 호출 그래프(call graph)를 탐색하거나, 때로는 명령어를 다른 명령어로 변환하는 작업을 수행해야 한다. 이를 위해서는 LLVM IR을 잘 다룰 수 있어야 하는데, 아래 표는 LLVM IR을 다룰 수 있는 여러 방법들을 설명해주고 있으니 좀 더 살펴보도록 하자.</p> <table> <thead> <tr> <th>Pass</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><a href="../000-Begining_LLVM(KOR)">Writing HelloLLVM Pass</a></td> <td>analysis</td> </tr> <tr> <td><a href="../001-Iterating_over_Module_Function_BasicBlock">Iterating over Module, Function, Basic block</a></td> <td>analysis</td> </tr> <tr> <td><a href="../002-Count_insts_calls">Count the number of insts, func calls</a></td> <td>analysis</td> </tr> <tr> <td><a href="../003-Insert_func_call">Insert func call</a></td> <td>transformation</td> </tr> <tr> <td><a href="../004-Change_Insts_(obfuscation)">Change Insts (obfuscation)</a></td> <td>transformation</td> </tr> <tr> <td><a href="../005-Traverse_CFG">Control flow graph</a></td> <td>transformation</td> </tr> </tbody> </table> <p>LLVM 튜토리얼을 잘 즐기셨나요? 이제는 프로그램 분석에 대해 알아보도록 합시다! <a href="./101-Program_analysis_with_LLVM">여기</a>로 오세요!</p> <h2 id="reference">Reference</h2> <p>[1] Andrzej Warzyński. llvm-tutor. <a href="https://github.com/banach-space/llvm-tutor">github</a><br/> [2] Adrian Sampson. LLVM for Grad Students. <a href="https://www.cs.cornell.edu/~asampson/blog/llvm.html">blog</a><br/> [3] Keshav Pingali. CS 380C: Advanced Topics in Compilers. <a href="https://www.cs.utexas.edu/~pingali/CS380C/2020/assignments/assignment4/index.html">blog</a><br/> [4] Arthur Eubanks. The New Pass Manager. <a href="https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager">blog</a> [5] Changbie. Compilation Optimization: LLVM Code Generation Technology Details and Its Application in Databases. <a href="https://www.alibabacloud.com/blog/compilation-optimization-llvm-code-generation-technology-details-and-its-application-in-databases_598408">post</a></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/000-Begining_LLVM/">000 An Introduction to LLVM</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/002-Count_insts_calls/">002 Count the number of instructions and function calls</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/004-Change_Insts_(obfuscation)/">004 Change Instructions (obfuscation)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/001-Iterating_over_Module_Function_BasicBlock/">001 Iterating Module, Function, and Basicblock with LLVM</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/005-Traverse_CFG/">005 Traverse Control flow graph</a> </li> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> &copy; Copyright 2024 Yongjin Han. Happy New Year! </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-M6YE7F4X7F"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-M6YE7F4X7F");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>